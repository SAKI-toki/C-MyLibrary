<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SakiCppLibrary: saki 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SakiCppLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">名前空間</a> &#124;
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">saki 名前空間</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
名前空間</h2></td></tr>
<tr class="memitem:namespacesaki_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesaki_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesaki_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesaki_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1addition.html">addition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">足し算のconstexpr対応した関数オブジェクト  <a href="structsaki_1_1addition.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時固定長配列クラス  <a href="classsaki_1_1array.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1array_3_01_t_00_010_01_4.html">array&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__begin.html">can_begin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">beginできるかどうかを判定する構造体  <a href="structsaki_1_1can__begin.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__different__equal.html">can_different_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">代入演算子を定義しているかどうかを判定する構造体(違う型同士)  <a href="structsaki_1_1can__different__equal.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__different__equal_3_01_t_00_01_t_01_4.html">can_different_equal&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__end.html">can_end</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">endできるかどうかを判定する構造体  <a href="structsaki_1_1can__end.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__equal__equal.html">can_equal_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">イコールイコール比較できるかどうかを判定する構造体(==)  <a href="structsaki_1_1can__equal__equal.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__greater.html">can_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">より大きい比較できるかどうかを判定する構造体(&gt;)  <a href="structsaki_1_1can__greater.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__greater__or__equal.html">can_greater_or_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">以上比較できるかどうかを判定する構造体(&gt;=)  <a href="structsaki_1_1can__greater__or__equal.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__less.html">can_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">より小さい比較できるかどうかを判定する構造体(&lt;)  <a href="structsaki_1_1can__less.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__less__or__equal.html">can_less_or_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">以下比較できるかどうかを判定する構造体(&lt;=)  <a href="structsaki_1_1can__less__or__equal.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__not__equal.html">can_not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ノットイコール比較できるかどうかを判定する構造体(!=)  <a href="structsaki_1_1can__not__equal.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__ostream.html">can_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream演算子をオーバーロードしているかどうか判定する構造体(cout)  <a href="structsaki_1_1can__ostream.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1can__range__based__for.html">can_range_based_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">範囲ベースfor文に利用できる型かどうか判定する  <a href="classsaki_1_1can__range__based__for.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1can__same__equal.html">can_same_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">代入演算子を定義しているかどうかを判定する構造体(同じ型同士)  <a href="structsaki_1_1can__same__equal.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1clock.html">clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">時間を測るクラス  <a href="classsaki_1_1clock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constなイテレーター  <a href="classsaki_1_1const__iterator.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constなリバースイテレーター  <a href="classsaki_1_1const__reverse__iterator.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1division.html">division</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">割り算のconstexpr対応した関数オブジェクト  <a href="structsaki_1_1division.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1double__constant.html">double_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">倍精度浮動小数点型の定数を表す  <a href="structsaki_1_1double__constant.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1enable__if__nullptr.html">enable_if_nullptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enalbe_ifのfalse  <a href="structsaki_1_1enable__if__nullptr.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1enable__if__nullptr_3_01true_01_4.html">enable_if_nullptr&lt; true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable_ifのtrue  <a href="structsaki_1_1enable__if__nullptr_3_01true_01_4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits.html">factorial_limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型ごとの最大階乗数  <a href="structsaki_1_1factorial__limits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01char_01_4.html">factorial_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01char16__t_01_4.html">factorial_limits&lt; char16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01char32__t_01_4.html">factorial_limits&lt; char32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01double_01_4.html">factorial_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01float_01_4.html">factorial_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01int_01_4.html">factorial_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01long_01_4.html">factorial_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01long_01double_01_4.html">factorial_limits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01long_01long_01_4.html">factorial_limits&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01short_01_4.html">factorial_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01unsigned_01char_01_4.html">factorial_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01unsigned_01int_01_4.html">factorial_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01unsigned_01long_01_4.html">factorial_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01unsigned_01long_01long_01_4.html">factorial_limits&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01unsigned_01short_01_4.html">factorial_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1factorial__limits_3_01wchar__t_01_4.html">factorial_limits&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits.html">fibonacci_limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型ごとのフィボナッチ数  <a href="structsaki_1_1fibonacci__limits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01char_01_4.html">fibonacci_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01char16__t_01_4.html">fibonacci_limits&lt; char16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01char32__t_01_4.html">fibonacci_limits&lt; char32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01double_01_4.html">fibonacci_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01float_01_4.html">fibonacci_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01int_01_4.html">fibonacci_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01long_01_4.html">fibonacci_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01long_01double_01_4.html">fibonacci_limits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01long_01long_01_4.html">fibonacci_limits&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01short_01_4.html">fibonacci_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01unsigned_01char_01_4.html">fibonacci_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01unsigned_01int_01_4.html">fibonacci_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01unsigned_01long_01_4.html">fibonacci_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01unsigned_01long_01long_01_4.html">fibonacci_limits&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01unsigned_01short_01_4.html">fibonacci_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1fibonacci__limits_3_01wchar__t_01_4.html">fibonacci_limits&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1float__constant.html">float_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">浮動小数点型の定数を表す  <a href="structsaki_1_1float__constant.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1has__check.html">has_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check関数を持っているかどうかを判定する構造体  <a href="structsaki_1_1has__check.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1has__x.html">has_x</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数xを持っているかどうかを判定する構造体  <a href="structsaki_1_1has__x.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1has__y.html">has_y</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数yを持っているかどうかを判定する構造体  <a href="structsaki_1_1has__y.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1has__z.html">has_z</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数yを持っているかどうかを判定する構造体  <a href="structsaki_1_1has__z.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ノーマルなイテレーター  <a href="classsaki_1_1iterator.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列  <a href="classsaki_1_1matrix.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1_multiple_separation.html">MultipleSeparation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">split関数で利用する、区切り文字を複数指定できるクラス  <a href="classsaki_1_1_multiple_separation.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1multiplication.html">multiplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">掛け算のconstexpr対応した関数オブジェクト  <a href="structsaki_1_1multiplication.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1_not_equal_separation.html">NotEqualSeparation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">split関数で利用する、区切らない文字を指定できるクラス  <a href="classsaki_1_1_not_equal_separation.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1remove__reference__const.html">remove_reference_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照とconst修飾を削除  <a href="structsaki_1_1remove__reference__const.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1return__param.html">return_param</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">そのまま引数を返す関数オブジェクト  <a href="structsaki_1_1return__param.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ノーマルなリバースイテレーター  <a href="classsaki_1_1reverse__iterator.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1singleton.html">singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">継承するとシングルトンクラスになる  <a href="classsaki_1_1singleton.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1string__base.html">string_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時固定長string_baseクラス  <a href="classsaki_1_1string__base.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1string__base_3_01_t_00_010_01_4.html">string_base&lt; T, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素数0  <a href="classsaki_1_1string__base_3_01_t_00_010_01_4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaki_1_1subtraction.html">subtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">引き算のconstexpr対応した関数オブジェクト  <a href="structsaki_1_1subtraction.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1transform.html">transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">transformクラス  <a href="classsaki_1_1transform.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1vector2.html">vector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元でのベクトル  <a href="classsaki_1_1vector2.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1vector3.html">vector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元でのベクトル  <a href="classsaki_1_1vector3.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaki_1_1vector4.html">vector4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4次元でのベクトル  <a href="classsaki_1_1vector4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:a47847d63f1d9c97ca37f33eeecb27674"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a47847d63f1d9c97ca37f33eeecb27674"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a47847d63f1d9c97ca37f33eeecb27674">string</a> = <a class="el" href="classsaki_1_1string__base.html">saki::string_base</a>&lt; char, N &gt;</td></tr>
<tr class="separator:a47847d63f1d9c97ca37f33eeecb27674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c362f5119aac94085eab0bf794facf7"><td class="memTemplParams" colspan="2">template&lt;bool Con&gt; </td></tr>
<tr class="memitem:a4c362f5119aac94085eab0bf794facf7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a4c362f5119aac94085eab0bf794facf7">enable_if_nullptr_t</a> = typename <a class="el" href="structsaki_1_1enable__if__nullptr.html">enable_if_nullptr</a>&lt; Con &gt;::type</td></tr>
<tr class="memdesc:a4c362f5119aac94085eab0bf794facf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable_if_nullptrを簡単に呼び出せる変数  <a href="#a4c362f5119aac94085eab0bf794facf7">[詳解]</a><br /></td></tr>
<tr class="separator:a4c362f5119aac94085eab0bf794facf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6964622fdfcdf489dab4b87727a8e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff6964622fdfcdf489dab4b87727a8e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aff6964622fdfcdf489dab4b87727a8e4">remove_reference_const_t</a> = typename <a class="el" href="structsaki_1_1remove__reference__const.html">saki::remove_reference_const</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:aff6964622fdfcdf489dab4b87727a8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove_reference_constを簡単に呼び出せるようにした  <a href="#aff6964622fdfcdf489dab4b87727a8e4">[詳解]</a><br /></td></tr>
<tr class="separator:aff6964622fdfcdf489dab4b87727a8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:abd8c75003f2a213607842f5d82eac806"><td class="memTemplParams" colspan="2">template&lt;typename Container1 , typename Container2 , typename saki::enable_if_nullptr_t&lt; saki::can_range_based_for_v&lt; Container1 &gt; &amp;&amp;saki::can_range_based_for_v&lt; Container2 &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:abd8c75003f2a213607842f5d82eac806"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abd8c75003f2a213607842f5d82eac806">copy</a> (const Container1 &amp;con1, Container2 &amp;con2) -&gt; decltype(*std::begin(con2)= *std::begin(con1), std::begin(con2))</td></tr>
<tr class="memdesc:abd8c75003f2a213607842f5d82eac806"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナとコンテナを渡すcopy  <a href="#abd8c75003f2a213607842f5d82eac806">[詳解]</a><br /></td></tr>
<tr class="separator:abd8c75003f2a213607842f5d82eac806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce8a66ed6ece15fa9ddeaec2746374d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Size&gt; </td></tr>
<tr class="memitem:a5ce8a66ed6ece15fa9ddeaec2746374d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5ce8a66ed6ece15fa9ddeaec2746374d">operator==</a> (const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;arr1, const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;arr2)</td></tr>
<tr class="memdesc:a5ce8a66ed6ece15fa9ddeaec2746374d"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子  <a href="#a5ce8a66ed6ece15fa9ddeaec2746374d">[詳解]</a><br /></td></tr>
<tr class="separator:a5ce8a66ed6ece15fa9ddeaec2746374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed742cc915a830fea9f4993c0a031c45"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Size&gt; </td></tr>
<tr class="memitem:aed742cc915a830fea9f4993c0a031c45"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aed742cc915a830fea9f4993c0a031c45">operator!=</a> (const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;arr1, const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;arr2)</td></tr>
<tr class="memdesc:aed742cc915a830fea9f4993c0a031c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子  <a href="#aed742cc915a830fea9f4993c0a031c45">[詳解]</a><br /></td></tr>
<tr class="separator:aed742cc915a830fea9f4993c0a031c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45597d7382905409bada2316f78502fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; saki::can_less_or_equal_v&lt; T &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a45597d7382905409bada2316f78502fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a45597d7382905409bada2316f78502fc">is_fit</a> (const T &amp;x, const T &amp;min_n, const T &amp;max_n)</td></tr>
<tr class="memdesc:a45597d7382905409bada2316f78502fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">範囲内かどうかの判定を行う  <a href="#a45597d7382905409bada2316f78502fc">[詳解]</a><br /></td></tr>
<tr class="separator:a45597d7382905409bada2316f78502fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09478d8cb01d75e93d34f884d7133dc9"><td class="memTemplParams" colspan="2">template&lt;typename First , typename MinType , typename MaxType , typename saki::enable_if_nullptr_t&lt; std::is_convertible_v&lt; MinType, First &gt; &amp;&amp;std::is_convertible_v&lt; MaxType, First &gt; &amp;&amp;saki::can_less_or_equal_v&lt; First &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a09478d8cb01d75e93d34f884d7133dc9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a09478d8cb01d75e93d34f884d7133dc9">is_fit</a> (First x, MinType min_n, MaxType max_n)</td></tr>
<tr class="memdesc:a09478d8cb01d75e93d34f884d7133dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">型をそろえる  <a href="#a09478d8cb01d75e93d34f884d7133dc9">[詳解]</a><br /></td></tr>
<tr class="separator:a09478d8cb01d75e93d34f884d7133dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b234a435a0e21df1507c4786b975b8"><td class="memTemplParams" colspan="2">template&lt;typename First , typename ... Args, typename saki::enable_if_nullptr_t&lt; std::conjunction_v&lt; std::is_convertible&lt; Args, First &gt;... &gt; &amp;&amp;std::conjunction_v&lt; saki::can_less&lt; First &gt;&gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a48b234a435a0e21df1507c4786b975b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a48b234a435a0e21df1507c4786b975b8">is_max</a> (const First &amp;first, const Args &amp;...args)</td></tr>
<tr class="memdesc:a48b234a435a0e21df1507c4786b975b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数の比較を一度に行える(&gt;=)  <a href="#a48b234a435a0e21df1507c4786b975b8">[詳解]</a><br /></td></tr>
<tr class="separator:a48b234a435a0e21df1507c4786b975b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780d542366428c85bfc48fdf43f54ee"><td class="memTemplParams" colspan="2">template&lt;typename First , typename ... Args, typename saki::enable_if_nullptr_t&lt; std::conjunction_v&lt; std::is_convertible&lt; First, Args &gt;... &gt; &amp;&amp;std::conjunction_v&lt; saki::can_greater&lt; First &gt;&gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a7780d542366428c85bfc48fdf43f54ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7780d542366428c85bfc48fdf43f54ee">is_min</a> (const First &amp;first, const Args &amp;...args)</td></tr>
<tr class="memdesc:a7780d542366428c85bfc48fdf43f54ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数の比較を一度に行える(&lt;=)  <a href="#a7780d542366428c85bfc48fdf43f54ee">[詳解]</a><br /></td></tr>
<tr class="separator:a7780d542366428c85bfc48fdf43f54ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15664a63445d3539b40b774e556a45b"><td class="memTemplParams" colspan="2">template&lt;typename First , typename ... Args, typename saki::enable_if_nullptr_t&lt; std::conjunction_v&lt; std::is_convertible&lt; First, Args &gt;... &gt; &amp;&amp;std::conjunction_v&lt; saki::can_equal_equal&lt; First &gt;&gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa15664a63445d3539b40b774e556a45b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa15664a63445d3539b40b774e556a45b">multi_equal</a> (const First &amp;first, const Args &amp;...args)</td></tr>
<tr class="memdesc:aa15664a63445d3539b40b774e556a45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数の比較を一度に行える  <a href="#aa15664a63445d3539b40b774e556a45b">[詳解]</a><br /></td></tr>
<tr class="separator:aa15664a63445d3539b40b774e556a45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cd607ad87b208aa6105b5d8287dc9e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt;!std::is_unsigned_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a37cd607ad87b208aa6105b5d8287dc9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a37cd607ad87b208aa6105b5d8287dc9e">abs</a> (T x)</td></tr>
<tr class="memdesc:a37cd607ad87b208aa6105b5d8287dc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時絶対値  <a href="#a37cd607ad87b208aa6105b5d8287dc9e">[詳解]</a><br /></td></tr>
<tr class="separator:a37cd607ad87b208aa6105b5d8287dc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189b75c5c7ecbf6d2204142da5fa813"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a3189b75c5c7ecbf6d2204142da5fa813"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a3189b75c5c7ecbf6d2204142da5fa813">acos</a> (T x)</td></tr>
<tr class="memdesc:a3189b75c5c7ecbf6d2204142da5fa813"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時acos  <a href="#a3189b75c5c7ecbf6d2204142da5fa813">[詳解]</a><br /></td></tr>
<tr class="separator:a3189b75c5c7ecbf6d2204142da5fa813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cad65bf92f361b4b564268af96a7844"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a2cad65bf92f361b4b564268af96a7844"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a2cad65bf92f361b4b564268af96a7844">acos</a> (T x)</td></tr>
<tr class="memdesc:a2cad65bf92f361b4b564268af96a7844"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a2cad65bf92f361b4b564268af96a7844">[詳解]</a><br /></td></tr>
<tr class="separator:a2cad65bf92f361b4b564268af96a7844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c85a4defc25dc9eb6b380f29946f83"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac1c85a4defc25dc9eb6b380f29946f83"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac1c85a4defc25dc9eb6b380f29946f83">acosh</a> (T x)</td></tr>
<tr class="memdesc:ac1c85a4defc25dc9eb6b380f29946f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時sinh  <a href="#ac1c85a4defc25dc9eb6b380f29946f83">[詳解]</a><br /></td></tr>
<tr class="separator:ac1c85a4defc25dc9eb6b380f29946f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3766d425082661e966b04504b90002"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a8d3766d425082661e966b04504b90002"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8d3766d425082661e966b04504b90002">acosh</a> (T x)</td></tr>
<tr class="memdesc:a8d3766d425082661e966b04504b90002"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a8d3766d425082661e966b04504b90002">[詳解]</a><br /></td></tr>
<tr class="separator:a8d3766d425082661e966b04504b90002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f2b40515cd62b037dade64aa8465db"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a63f2b40515cd62b037dade64aa8465db"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a63f2b40515cd62b037dade64aa8465db">asin</a> (T x)</td></tr>
<tr class="memdesc:a63f2b40515cd62b037dade64aa8465db"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時asin  <a href="#a63f2b40515cd62b037dade64aa8465db">[詳解]</a><br /></td></tr>
<tr class="separator:a63f2b40515cd62b037dade64aa8465db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac285debedd1f53761a838c0e4f57af0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aac285debedd1f53761a838c0e4f57af0"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aac285debedd1f53761a838c0e4f57af0">asin</a> (T x)</td></tr>
<tr class="memdesc:aac285debedd1f53761a838c0e4f57af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#aac285debedd1f53761a838c0e4f57af0">[詳解]</a><br /></td></tr>
<tr class="separator:aac285debedd1f53761a838c0e4f57af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097a2d600f313b6bdd3099e61a10b9e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab097a2d600f313b6bdd3099e61a10b9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab097a2d600f313b6bdd3099e61a10b9e">asinh</a> (T x)</td></tr>
<tr class="memdesc:ab097a2d600f313b6bdd3099e61a10b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時asinh  <a href="#ab097a2d600f313b6bdd3099e61a10b9e">[詳解]</a><br /></td></tr>
<tr class="separator:ab097a2d600f313b6bdd3099e61a10b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac840ca5d9b98ac0a8c5b15752f02072"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aac840ca5d9b98ac0a8c5b15752f02072"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aac840ca5d9b98ac0a8c5b15752f02072">asinh</a> (T x)</td></tr>
<tr class="memdesc:aac840ca5d9b98ac0a8c5b15752f02072"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#aac840ca5d9b98ac0a8c5b15752f02072">[詳解]</a><br /></td></tr>
<tr class="separator:aac840ca5d9b98ac0a8c5b15752f02072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b9439c745f69bd8a8b681b03b4b01"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a524b9439c745f69bd8a8b681b03b4b01"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a524b9439c745f69bd8a8b681b03b4b01">atan</a> (T x)</td></tr>
<tr class="memdesc:a524b9439c745f69bd8a8b681b03b4b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時atan  <a href="#a524b9439c745f69bd8a8b681b03b4b01">[詳解]</a><br /></td></tr>
<tr class="separator:a524b9439c745f69bd8a8b681b03b4b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8a08085fc9210a4e8d61f6c04febe2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:acd8a08085fc9210a4e8d61f6c04febe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#acd8a08085fc9210a4e8d61f6c04febe2">atan</a> (T x)</td></tr>
<tr class="memdesc:acd8a08085fc9210a4e8d61f6c04febe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#acd8a08085fc9210a4e8d61f6c04febe2">[詳解]</a><br /></td></tr>
<tr class="separator:acd8a08085fc9210a4e8d61f6c04febe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac528a4ab6013623bfe6257229e302015"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac528a4ab6013623bfe6257229e302015"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac528a4ab6013623bfe6257229e302015">atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:ac528a4ab6013623bfe6257229e302015"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時atan2  <a href="#ac528a4ab6013623bfe6257229e302015">[詳解]</a><br /></td></tr>
<tr class="separator:ac528a4ab6013623bfe6257229e302015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c6dc6223b790f6d227c8d22cf8b86"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a1f8c6dc6223b790f6d227c8d22cf8b86"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a1f8c6dc6223b790f6d227c8d22cf8b86">atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:a1f8c6dc6223b790f6d227c8d22cf8b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a1f8c6dc6223b790f6d227c8d22cf8b86">[詳解]</a><br /></td></tr>
<tr class="separator:a1f8c6dc6223b790f6d227c8d22cf8b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c656a9f2a0c0cfe522fb95ac37128cc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5c656a9f2a0c0cfe522fb95ac37128cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5c656a9f2a0c0cfe522fb95ac37128cc">atan2</a> (T1 y, T2 x)</td></tr>
<tr class="memdesc:a5c656a9f2a0c0cfe522fb95ac37128cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">型をそろえる  <a href="#a5c656a9f2a0c0cfe522fb95ac37128cc">[詳解]</a><br /></td></tr>
<tr class="separator:a5c656a9f2a0c0cfe522fb95ac37128cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfceeab527c51676d00fae31e077dcf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:adbfceeab527c51676d00fae31e077dcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#adbfceeab527c51676d00fae31e077dcf">atanh</a> (T x)</td></tr>
<tr class="memdesc:adbfceeab527c51676d00fae31e077dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時atanh  <a href="#adbfceeab527c51676d00fae31e077dcf">[詳解]</a><br /></td></tr>
<tr class="separator:adbfceeab527c51676d00fae31e077dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d87f99b61600e1201b10de467200f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a1b7d87f99b61600e1201b10de467200f"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a1b7d87f99b61600e1201b10de467200f">atanh</a> (T x)</td></tr>
<tr class="memdesc:a1b7d87f99b61600e1201b10de467200f"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a1b7d87f99b61600e1201b10de467200f">[詳解]</a><br /></td></tr>
<tr class="separator:a1b7d87f99b61600e1201b10de467200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8836c929b71a61cf0151d3b76eb7af15"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a8836c929b71a61cf0151d3b76eb7af15"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8836c929b71a61cf0151d3b76eb7af15">cbrt</a> (T x)</td></tr>
<tr class="memdesc:a8836c929b71a61cf0151d3b76eb7af15"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時cbrt  <a href="#a8836c929b71a61cf0151d3b76eb7af15">[詳解]</a><br /></td></tr>
<tr class="separator:a8836c929b71a61cf0151d3b76eb7af15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3d1ab0508dcff1fb2e17a4ef8a855d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a5a3d1ab0508dcff1fb2e17a4ef8a855d"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5a3d1ab0508dcff1fb2e17a4ef8a855d">cbrt</a> (T x)</td></tr>
<tr class="memdesc:a5a3d1ab0508dcff1fb2e17a4ef8a855d"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a5a3d1ab0508dcff1fb2e17a4ef8a855d">[詳解]</a><br /></td></tr>
<tr class="separator:a5a3d1ab0508dcff1fb2e17a4ef8a855d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bab6303ac2144b883080f04ebe26a0e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SignType &gt; </td></tr>
<tr class="memitem:a8bab6303ac2144b883080f04ebe26a0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8bab6303ac2144b883080f04ebe26a0e">copysign</a> (const T &amp;x, const SignType &amp;y)</td></tr>
<tr class="memdesc:a8bab6303ac2144b883080f04ebe26a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時符号コピー  <a href="#a8bab6303ac2144b883080f04ebe26a0e">[詳解]</a><br /></td></tr>
<tr class="separator:a8bab6303ac2144b883080f04ebe26a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82551963a8cab889ca6f76ed346d6f4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a82551963a8cab889ca6f76ed346d6f4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a82551963a8cab889ca6f76ed346d6f4f">cos</a> (T x)</td></tr>
<tr class="memdesc:a82551963a8cab889ca6f76ed346d6f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時cos  <a href="#a82551963a8cab889ca6f76ed346d6f4f">[詳解]</a><br /></td></tr>
<tr class="separator:a82551963a8cab889ca6f76ed346d6f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f49aa2d1182883ae8b4c01b346cc88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab1f49aa2d1182883ae8b4c01b346cc88"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab1f49aa2d1182883ae8b4c01b346cc88">cos</a> (T x)</td></tr>
<tr class="memdesc:ab1f49aa2d1182883ae8b4c01b346cc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#ab1f49aa2d1182883ae8b4c01b346cc88">[詳解]</a><br /></td></tr>
<tr class="separator:ab1f49aa2d1182883ae8b4c01b346cc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8167af6da5c9eb510d33dadae13708"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a0f8167af6da5c9eb510d33dadae13708"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a0f8167af6da5c9eb510d33dadae13708">cosh</a> (T x)</td></tr>
<tr class="memdesc:a0f8167af6da5c9eb510d33dadae13708"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時cosh  <a href="#a0f8167af6da5c9eb510d33dadae13708">[詳解]</a><br /></td></tr>
<tr class="separator:a0f8167af6da5c9eb510d33dadae13708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe248729248030bd5858469409e902d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:afe248729248030bd5858469409e902d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#afe248729248030bd5858469409e902d2">cosh</a> (T x)</td></tr>
<tr class="memdesc:afe248729248030bd5858469409e902d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#afe248729248030bd5858469409e902d2">[詳解]</a><br /></td></tr>
<tr class="separator:afe248729248030bd5858469409e902d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27595b1e53058ce792db7f8d29e2e9af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a27595b1e53058ce792db7f8d29e2e9af"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a27595b1e53058ce792db7f8d29e2e9af">to_radian</a> (T deg)</td></tr>
<tr class="memdesc:a27595b1e53058ce792db7f8d29e2e9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">DegreeからRadianに変換  <a href="#a27595b1e53058ce792db7f8d29e2e9af">[詳解]</a><br /></td></tr>
<tr class="separator:a27595b1e53058ce792db7f8d29e2e9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa671d122197cf10439eee0d271f51fe6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa671d122197cf10439eee0d271f51fe6"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa671d122197cf10439eee0d271f51fe6">to_radian</a> (T deg)</td></tr>
<tr class="memdesc:aa671d122197cf10439eee0d271f51fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#aa671d122197cf10439eee0d271f51fe6">[詳解]</a><br /></td></tr>
<tr class="separator:aa671d122197cf10439eee0d271f51fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f6d8f2c0663a0452c7edd17bf5daf0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:af9f6d8f2c0663a0452c7edd17bf5daf0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af9f6d8f2c0663a0452c7edd17bf5daf0">to_degree</a> (T rad)</td></tr>
<tr class="memdesc:af9f6d8f2c0663a0452c7edd17bf5daf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">RadianからDegreeに変換  <a href="#af9f6d8f2c0663a0452c7edd17bf5daf0">[詳解]</a><br /></td></tr>
<tr class="separator:af9f6d8f2c0663a0452c7edd17bf5daf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cb33956f8d7354b485aee878d7805d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa7cb33956f8d7354b485aee878d7805d"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa7cb33956f8d7354b485aee878d7805d">to_degree</a> (T rad)</td></tr>
<tr class="memdesc:aa7cb33956f8d7354b485aee878d7805d"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#aa7cb33956f8d7354b485aee878d7805d">[詳解]</a><br /></td></tr>
<tr class="separator:aa7cb33956f8d7354b485aee878d7805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467dee57b7bbe101146713a82acfe95e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_arithmetic_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a467dee57b7bbe101146713a82acfe95e"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a467dee57b7bbe101146713a82acfe95e">digit_count</a> (T x)</td></tr>
<tr class="memdesc:a467dee57b7bbe101146713a82acfe95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">整数部の桁数を数える関数  <a href="#a467dee57b7bbe101146713a82acfe95e">[詳解]</a><br /></td></tr>
<tr class="separator:a467dee57b7bbe101146713a82acfe95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eddecfb6a747238185b21c8ee1cd60"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_x_v&lt; T1 &gt; &amp;&amp;saki::has_x_v&lt; T2 &gt; &amp;&amp;saki::has_y_v&lt; T1 &gt; &amp;&amp;saki::has_y_v&lt; T2 &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ae6eddecfb6a747238185b21c8ee1cd60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ae6eddecfb6a747238185b21c8ee1cd60">distanceXY</a> (const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:ae6eddecfb6a747238185b21c8ee1cd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">二点間の距離(XY)  <a href="#ae6eddecfb6a747238185b21c8ee1cd60">[詳解]</a><br /></td></tr>
<tr class="separator:ae6eddecfb6a747238185b21c8ee1cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd1999d77d0ba6f6101747d82593c66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_x_v&lt; T1 &gt; &amp;&amp;saki::has_x_v&lt; T2 &gt; &amp;&amp;saki::has_z_v&lt; T1 &gt; &amp;&amp;saki::has_z_v&lt; T2 &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a6bd1999d77d0ba6f6101747d82593c66"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a6bd1999d77d0ba6f6101747d82593c66">distanceXZ</a> (const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:a6bd1999d77d0ba6f6101747d82593c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">二点間の距離(XZ)  <a href="#a6bd1999d77d0ba6f6101747d82593c66">[詳解]</a><br /></td></tr>
<tr class="separator:a6bd1999d77d0ba6f6101747d82593c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708a45bd2134a3a276e7acb2566eb8c1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_y_v&lt; T1 &gt; &amp;&amp;saki::has_y_v&lt; T2 &gt; &amp;&amp;saki::has_z_v&lt; T1 &gt; &amp;&amp;saki::has_z_v&lt; T2 &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a708a45bd2134a3a276e7acb2566eb8c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a708a45bd2134a3a276e7acb2566eb8c1">distanceYZ</a> (const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:a708a45bd2134a3a276e7acb2566eb8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">二点間の距離(YZ)  <a href="#a708a45bd2134a3a276e7acb2566eb8c1">[詳解]</a><br /></td></tr>
<tr class="separator:a708a45bd2134a3a276e7acb2566eb8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af202425b916b22c2b3a26731689d5c21"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_x_v&lt; T1 &gt; &amp;&amp;saki::has_x_v&lt; T2 &gt; &amp;&amp;saki::has_y_v&lt; T1 &gt; &amp;&amp;saki::has_y_v&lt; T2 &gt; &amp;&amp;saki::has_z_v&lt; T1 &gt; &amp;&amp;saki::has_z_v&lt; T2 &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:af202425b916b22c2b3a26731689d5c21"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af202425b916b22c2b3a26731689d5c21">distanceXYZ</a> (const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:af202425b916b22c2b3a26731689d5c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">二点間の距離(XYZ)  <a href="#af202425b916b22c2b3a26731689d5c21">[詳解]</a><br /></td></tr>
<tr class="separator:af202425b916b22c2b3a26731689d5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0188c33098d6ac615fc71e64ab6dda"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = T&gt; </td></tr>
<tr class="memitem:ace0188c33098d6ac615fc71e64ab6dda"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ace0188c33098d6ac615fc71e64ab6dda">exchange</a> (T &amp;obj, U &amp;&amp;new_val)</td></tr>
<tr class="memdesc:ace0188c33098d6ac615fc71e64ab6dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時exchange  <a href="#ace0188c33098d6ac615fc71e64ab6dda">[詳解]</a><br /></td></tr>
<tr class="separator:ace0188c33098d6ac615fc71e64ab6dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1268e543a60d43b04f1418f5ef3e41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:abc1268e543a60d43b04f1418f5ef3e41"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abc1268e543a60d43b04f1418f5ef3e41">exp</a> (T x)</td></tr>
<tr class="memdesc:abc1268e543a60d43b04f1418f5ef3e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時exp  <a href="#abc1268e543a60d43b04f1418f5ef3e41">[詳解]</a><br /></td></tr>
<tr class="separator:abc1268e543a60d43b04f1418f5ef3e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7883c6dfd2cf3ae04993f64d98345fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab7883c6dfd2cf3ae04993f64d98345fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab7883c6dfd2cf3ae04993f64d98345fc">exp</a> (T x)</td></tr>
<tr class="memdesc:ab7883c6dfd2cf3ae04993f64d98345fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#ab7883c6dfd2cf3ae04993f64d98345fc">[詳解]</a><br /></td></tr>
<tr class="separator:ab7883c6dfd2cf3ae04993f64d98345fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2d4ba08357bbab05c97ae261c80343"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a2e2d4ba08357bbab05c97ae261c80343"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a2e2d4ba08357bbab05c97ae261c80343">exp2</a> (T x)</td></tr>
<tr class="memdesc:a2e2d4ba08357bbab05c97ae261c80343"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時exp2  <a href="#a2e2d4ba08357bbab05c97ae261c80343">[詳解]</a><br /></td></tr>
<tr class="separator:a2e2d4ba08357bbab05c97ae261c80343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e9ce74a5f65c8d38a4901bf513ac1e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a35e9ce74a5f65c8d38a4901bf513ac1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a35e9ce74a5f65c8d38a4901bf513ac1e">exp2</a> (T x)</td></tr>
<tr class="memdesc:a35e9ce74a5f65c8d38a4901bf513ac1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a35e9ce74a5f65c8d38a4901bf513ac1e">[詳解]</a><br /></td></tr>
<tr class="separator:a35e9ce74a5f65c8d38a4901bf513ac1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb63a6251c75f6f1e76a58f5438de69"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aabb63a6251c75f6f1e76a58f5438de69"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aabb63a6251c75f6f1e76a58f5438de69">expm1</a> (T x)</td></tr>
<tr class="memdesc:aabb63a6251c75f6f1e76a58f5438de69"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時expm1  <a href="#aabb63a6251c75f6f1e76a58f5438de69">[詳解]</a><br /></td></tr>
<tr class="separator:aabb63a6251c75f6f1e76a58f5438de69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4490f448ed3d82712306c54d6821788"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ae4490f448ed3d82712306c54d6821788"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ae4490f448ed3d82712306c54d6821788">expm1</a> (T x)</td></tr>
<tr class="memdesc:ae4490f448ed3d82712306c54d6821788"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#ae4490f448ed3d82712306c54d6821788">[詳解]</a><br /></td></tr>
<tr class="separator:ae4490f448ed3d82712306c54d6821788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224c4843b72acf995e13809a5caaafd8"><td class="memTemplParams" colspan="2">template&lt;typename T  = double&gt; </td></tr>
<tr class="memitem:a224c4843b72acf995e13809a5caaafd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a224c4843b72acf995e13809a5caaafd8">factorial</a> (size_t N)</td></tr>
<tr class="memdesc:a224c4843b72acf995e13809a5caaafd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">階乗(引数バージョン)  <a href="#a224c4843b72acf995e13809a5caaafd8">[詳解]</a><br /></td></tr>
<tr class="separator:a224c4843b72acf995e13809a5caaafd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dead910b791cee99cf82d1bd2a5d90c"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T  = double&gt; </td></tr>
<tr class="memitem:a9dead910b791cee99cf82d1bd2a5d90c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a9dead910b791cee99cf82d1bd2a5d90c">factorial</a> ()</td></tr>
<tr class="memdesc:a9dead910b791cee99cf82d1bd2a5d90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">階乗(仮引数バージョン)  <a href="#a9dead910b791cee99cf82d1bd2a5d90c">[詳解]</a><br /></td></tr>
<tr class="separator:a9dead910b791cee99cf82d1bd2a5d90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bb6ae29766c4204c1cf8dc5bab007c"><td class="memTemplParams" colspan="2">template&lt;typename T  = double&gt; </td></tr>
<tr class="memitem:a93bb6ae29766c4204c1cf8dc5bab007c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a93bb6ae29766c4204c1cf8dc5bab007c">fibonacci</a> (size_t N)</td></tr>
<tr class="memdesc:a93bb6ae29766c4204c1cf8dc5bab007c"><td class="mdescLeft">&#160;</td><td class="mdescRight">フィボナッチ数列求める関数  <a href="#a93bb6ae29766c4204c1cf8dc5bab007c">[詳解]</a><br /></td></tr>
<tr class="separator:a93bb6ae29766c4204c1cf8dc5bab007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbb434ee3c6d77eeb32b85bb9e316f0"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename T  = double&gt; </td></tr>
<tr class="memitem:a7bbb434ee3c6d77eeb32b85bb9e316f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7bbb434ee3c6d77eeb32b85bb9e316f0">fibonacci</a> ()</td></tr>
<tr class="memdesc:a7bbb434ee3c6d77eeb32b85bb9e316f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">フィボナッチ数列を求める関数  <a href="#a7bbb434ee3c6d77eeb32b85bb9e316f0">[詳解]</a><br /></td></tr>
<tr class="separator:a7bbb434ee3c6d77eeb32b85bb9e316f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0718c031975604811084b62bbba93f7f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a0718c031975604811084b62bbba93f7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a0718c031975604811084b62bbba93f7f">floor</a> (T x)</td></tr>
<tr class="memdesc:a0718c031975604811084b62bbba93f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時floor  <a href="#a0718c031975604811084b62bbba93f7f">[詳解]</a><br /></td></tr>
<tr class="separator:a0718c031975604811084b62bbba93f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327cd6800fef212948644f69cb31d4ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a327cd6800fef212948644f69cb31d4ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a327cd6800fef212948644f69cb31d4ff">floor</a> (T x)</td></tr>
<tr class="memdesc:a327cd6800fef212948644f69cb31d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a327cd6800fef212948644f69cb31d4ff">[詳解]</a><br /></td></tr>
<tr class="separator:a327cd6800fef212948644f69cb31d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7b926b9d370e4a9aed84579675222c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a8a7b926b9d370e4a9aed84579675222c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8a7b926b9d370e4a9aed84579675222c">fmod</a> (T x, T y)</td></tr>
<tr class="memdesc:a8a7b926b9d370e4a9aed84579675222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時float,double剰余  <a href="#a8a7b926b9d370e4a9aed84579675222c">[詳解]</a><br /></td></tr>
<tr class="separator:a8a7b926b9d370e4a9aed84579675222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d00b62957aebad23850e2f470a8d9c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac9d00b62957aebad23850e2f470a8d9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac9d00b62957aebad23850e2f470a8d9c">fmod</a> (T1 x, T2 y) -&gt; decltype(x *y)</td></tr>
<tr class="memdesc:ac9d00b62957aebad23850e2f470a8d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">型が違う場合はそろえる  <a href="#ac9d00b62957aebad23850e2f470a8d9c">[詳解]</a><br /></td></tr>
<tr class="separator:ac9d00b62957aebad23850e2f470a8d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00438d1cd099cfd0e2938f9e3defd283"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a00438d1cd099cfd0e2938f9e3defd283"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a00438d1cd099cfd0e2938f9e3defd283">frexp</a> (T value, int *<a class="el" href="namespacesaki.html#abc1268e543a60d43b04f1418f5ef3e41">exp</a>)</td></tr>
<tr class="memdesc:a00438d1cd099cfd0e2938f9e3defd283"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時frexp  <a href="#a00438d1cd099cfd0e2938f9e3defd283">[詳解]</a><br /></td></tr>
<tr class="separator:a00438d1cd099cfd0e2938f9e3defd283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915bdd850c89e1ed06c5087790109f11"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a915bdd850c89e1ed06c5087790109f11"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a915bdd850c89e1ed06c5087790109f11">frexp</a> (T value, int *<a class="el" href="namespacesaki.html#abc1268e543a60d43b04f1418f5ef3e41">exp</a>)</td></tr>
<tr class="memdesc:a915bdd850c89e1ed06c5087790109f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a915bdd850c89e1ed06c5087790109f11">[詳解]</a><br /></td></tr>
<tr class="separator:a915bdd850c89e1ed06c5087790109f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfe75bfa0e5223a0390c5e2941e69bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a0dfe75bfa0e5223a0390c5e2941e69bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a0dfe75bfa0e5223a0390c5e2941e69bc">hypot</a> (T x, T y)</td></tr>
<tr class="memdesc:a0dfe75bfa0e5223a0390c5e2941e69bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">&mdash;&mdash;2引数--&mdash;&mdash;  <a href="#a0dfe75bfa0e5223a0390c5e2941e69bc">[詳解]</a><br /></td></tr>
<tr class="separator:a0dfe75bfa0e5223a0390c5e2941e69bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad888da163ba5c006d664d564fb48f7a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad888da163ba5c006d664d564fb48f7a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ad888da163ba5c006d664d564fb48f7a7">hypot</a> (T x, T y)</td></tr>
<tr class="memdesc:ad888da163ba5c006d664d564fb48f7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#ad888da163ba5c006d664d564fb48f7a7">[詳解]</a><br /></td></tr>
<tr class="separator:ad888da163ba5c006d664d564fb48f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6327614e0d389d7545d1ffb151602b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:add6327614e0d389d7545d1ffb151602b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#add6327614e0d389d7545d1ffb151602b">hypot</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:add6327614e0d389d7545d1ffb151602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">型が違う場合はそろえる  <a href="#add6327614e0d389d7545d1ffb151602b">[詳解]</a><br /></td></tr>
<tr class="separator:add6327614e0d389d7545d1ffb151602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56768ecf1270205a8c9b3ac8cdf4a590"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a56768ecf1270205a8c9b3ac8cdf4a590"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a56768ecf1270205a8c9b3ac8cdf4a590">hypot</a> (T x, T y, T z)</td></tr>
<tr class="memdesc:a56768ecf1270205a8c9b3ac8cdf4a590"><td class="mdescLeft">&#160;</td><td class="mdescRight">&mdash;&mdash;3引数--&mdash;&mdash;  <a href="#a56768ecf1270205a8c9b3ac8cdf4a590">[詳解]</a><br /></td></tr>
<tr class="separator:a56768ecf1270205a8c9b3ac8cdf4a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56e1232bb063b3bc0e7cf2b3f655247"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad56e1232bb063b3bc0e7cf2b3f655247"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ad56e1232bb063b3bc0e7cf2b3f655247">hypot</a> (T x, T y, T z)</td></tr>
<tr class="memdesc:ad56e1232bb063b3bc0e7cf2b3f655247"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#ad56e1232bb063b3bc0e7cf2b3f655247">[詳解]</a><br /></td></tr>
<tr class="separator:ad56e1232bb063b3bc0e7cf2b3f655247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6f15bbf909992e4840325c0dae0c42"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ada6f15bbf909992e4840325c0dae0c42"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ada6f15bbf909992e4840325c0dae0c42">hypot</a> (T1 x, T2 y, T3 z)</td></tr>
<tr class="memdesc:ada6f15bbf909992e4840325c0dae0c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">型が違う場合はそろえる  <a href="#ada6f15bbf909992e4840325c0dae0c42">[詳解]</a><br /></td></tr>
<tr class="separator:ada6f15bbf909992e4840325c0dae0c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582e9de82aa8572287c01530ae2626a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a582e9de82aa8572287c01530ae2626a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a582e9de82aa8572287c01530ae2626a8">ilogb</a> (T x)</td></tr>
<tr class="memdesc:a582e9de82aa8572287c01530ae2626a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時ilogb  <a href="#a582e9de82aa8572287c01530ae2626a8">[詳解]</a><br /></td></tr>
<tr class="separator:a582e9de82aa8572287c01530ae2626a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cf21b9e2231e956f8da966f1e09d70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03cf21b9e2231e956f8da966f1e09d70"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a03cf21b9e2231e956f8da966f1e09d70">is_odd</a> (T x)</td></tr>
<tr class="memdesc:a03cf21b9e2231e956f8da966f1e09d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">奇数がどうか判定する関数  <a href="#a03cf21b9e2231e956f8da966f1e09d70">[詳解]</a><br /></td></tr>
<tr class="separator:a03cf21b9e2231e956f8da966f1e09d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa7e4ec89e948874e42926e91d6dd4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fa7e4ec89e948874e42926e91d6dd4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7fa7e4ec89e948874e42926e91d6dd4e">is_even</a> (T x)</td></tr>
<tr class="memdesc:a7fa7e4ec89e948874e42926e91d6dd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">偶数がどうか判定する関数  <a href="#a7fa7e4ec89e948874e42926e91d6dd4e">[詳解]</a><br /></td></tr>
<tr class="separator:a7fa7e4ec89e948874e42926e91d6dd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2168418bb30a857d2d018d0d05c7ace0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a2168418bb30a857d2d018d0d05c7ace0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a2168418bb30a857d2d018d0d05c7ace0">isinf</a> (T x)</td></tr>
<tr class="memdesc:a2168418bb30a857d2d018d0d05c7ace0"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時isinf  <a href="#a2168418bb30a857d2d018d0d05c7ace0">[詳解]</a><br /></td></tr>
<tr class="separator:a2168418bb30a857d2d018d0d05c7ace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ca3f39e4dc8e57db4aafa03a4e232"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a446ca3f39e4dc8e57db4aafa03a4e232"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a446ca3f39e4dc8e57db4aafa03a4e232">isnan</a> (T x)</td></tr>
<tr class="memdesc:a446ca3f39e4dc8e57db4aafa03a4e232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not a Numberかどうか判定  <a href="#a446ca3f39e4dc8e57db4aafa03a4e232">[詳解]</a><br /></td></tr>
<tr class="separator:a446ca3f39e4dc8e57db4aafa03a4e232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b7a22945dcbce6e2bb0593025c90c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IntegerT , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; IntegerT &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a03b7a22945dcbce6e2bb0593025c90c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a03b7a22945dcbce6e2bb0593025c90c4">ldexp</a> (T x, IntegerT <a class="el" href="namespacesaki.html#abc1268e543a60d43b04f1418f5ef3e41">exp</a>)</td></tr>
<tr class="memdesc:a03b7a22945dcbce6e2bb0593025c90c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時ldexp  <a href="#a03b7a22945dcbce6e2bb0593025c90c4">[詳解]</a><br /></td></tr>
<tr class="separator:a03b7a22945dcbce6e2bb0593025c90c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64136b916afd50ceb9bfb93ae12c63fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a64136b916afd50ceb9bfb93ae12c63fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a64136b916afd50ceb9bfb93ae12c63fb">log</a> (T x)</td></tr>
<tr class="memdesc:a64136b916afd50ceb9bfb93ae12c63fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時log  <a href="#a64136b916afd50ceb9bfb93ae12c63fb">[詳解]</a><br /></td></tr>
<tr class="separator:a64136b916afd50ceb9bfb93ae12c63fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f260fd4311e2bd21ae770f8aed6fa81"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a7f260fd4311e2bd21ae770f8aed6fa81"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7f260fd4311e2bd21ae770f8aed6fa81">log</a> (T x)</td></tr>
<tr class="memdesc:a7f260fd4311e2bd21ae770f8aed6fa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a7f260fd4311e2bd21ae770f8aed6fa81">[詳解]</a><br /></td></tr>
<tr class="separator:a7f260fd4311e2bd21ae770f8aed6fa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a5f3dfe15009e9e985b8b0647211e6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa1a5f3dfe15009e9e985b8b0647211e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa1a5f3dfe15009e9e985b8b0647211e6">log10</a> (T x)</td></tr>
<tr class="memdesc:aa1a5f3dfe15009e9e985b8b0647211e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時log10  <a href="#aa1a5f3dfe15009e9e985b8b0647211e6">[詳解]</a><br /></td></tr>
<tr class="separator:aa1a5f3dfe15009e9e985b8b0647211e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5fde452567de6eaae1d5c481497757"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a7e5fde452567de6eaae1d5c481497757"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7e5fde452567de6eaae1d5c481497757">log10</a> (T x)</td></tr>
<tr class="memdesc:a7e5fde452567de6eaae1d5c481497757"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a7e5fde452567de6eaae1d5c481497757">[詳解]</a><br /></td></tr>
<tr class="separator:a7e5fde452567de6eaae1d5c481497757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2550b674acc69fa1fbe407917fdc7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ae0b2550b674acc69fa1fbe407917fdc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ae0b2550b674acc69fa1fbe407917fdc7">log1p</a> (T x)</td></tr>
<tr class="memdesc:ae0b2550b674acc69fa1fbe407917fdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時log1p  <a href="#ae0b2550b674acc69fa1fbe407917fdc7">[詳解]</a><br /></td></tr>
<tr class="separator:ae0b2550b674acc69fa1fbe407917fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec755aa143bd9a0d03c5ebb2dc5dd3de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aec755aa143bd9a0d03c5ebb2dc5dd3de"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aec755aa143bd9a0d03c5ebb2dc5dd3de">log1p</a> (T x)</td></tr>
<tr class="memdesc:aec755aa143bd9a0d03c5ebb2dc5dd3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#aec755aa143bd9a0d03c5ebb2dc5dd3de">[詳解]</a><br /></td></tr>
<tr class="separator:aec755aa143bd9a0d03c5ebb2dc5dd3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184cde6c3531e01531219e081e25452"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac184cde6c3531e01531219e081e25452"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac184cde6c3531e01531219e081e25452">log2</a> (T x)</td></tr>
<tr class="memdesc:ac184cde6c3531e01531219e081e25452"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時log2  <a href="#ac184cde6c3531e01531219e081e25452">[詳解]</a><br /></td></tr>
<tr class="separator:ac184cde6c3531e01531219e081e25452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb2f664389aab32abc797d9a60db4dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a8cb2f664389aab32abc797d9a60db4dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8cb2f664389aab32abc797d9a60db4dc">log2</a> (T x)</td></tr>
<tr class="memdesc:a8cb2f664389aab32abc797d9a60db4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a8cb2f664389aab32abc797d9a60db4dc">[詳解]</a><br /></td></tr>
<tr class="separator:a8cb2f664389aab32abc797d9a60db4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e81af48b13fbf88f135d296471bac1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab7e81af48b13fbf88f135d296471bac1"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab7e81af48b13fbf88f135d296471bac1">logb</a> (T x)</td></tr>
<tr class="memdesc:ab7e81af48b13fbf88f135d296471bac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時logb  <a href="#ab7e81af48b13fbf88f135d296471bac1">[詳解]</a><br /></td></tr>
<tr class="separator:ab7e81af48b13fbf88f135d296471bac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4ba562bb9897e98b75eb95027bfad5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:adf4ba562bb9897e98b75eb95027bfad5"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#adf4ba562bb9897e98b75eb95027bfad5">logb</a> (T x)</td></tr>
<tr class="memdesc:adf4ba562bb9897e98b75eb95027bfad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#adf4ba562bb9897e98b75eb95027bfad5">[詳解]</a><br /></td></tr>
<tr class="separator:adf4ba562bb9897e98b75eb95027bfad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b66f18d7c8c94b4c50731449ed3240"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa5b66f18d7c8c94b4c50731449ed3240"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa5b66f18d7c8c94b4c50731449ed3240">pow</a> (T x, T y)</td></tr>
<tr class="memdesc:aa5b66f18d7c8c94b4c50731449ed3240"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時累乗  <a href="#aa5b66f18d7c8c94b4c50731449ed3240">[詳解]</a><br /></td></tr>
<tr class="separator:aa5b66f18d7c8c94b4c50731449ed3240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b0e93733e85d7c6ab17aea25072536"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a53b0e93733e85d7c6ab17aea25072536"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a53b0e93733e85d7c6ab17aea25072536">pow</a> (T x, T y)</td></tr>
<tr class="memdesc:a53b0e93733e85d7c6ab17aea25072536"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a53b0e93733e85d7c6ab17aea25072536">[詳解]</a><br /></td></tr>
<tr class="separator:a53b0e93733e85d7c6ab17aea25072536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1168d9c20adf475c0a27670925c34"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aede1168d9c20adf475c0a27670925c34"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aede1168d9c20adf475c0a27670925c34">pow</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:aede1168d9c20adf475c0a27670925c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">型をそろえる  <a href="#aede1168d9c20adf475c0a27670925c34">[詳解]</a><br /></td></tr>
<tr class="separator:aede1168d9c20adf475c0a27670925c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51e06f83630682641e0d99d5c957a9c"><td class="memTemplParams" colspan="2">template&lt;typename T  = int, typename Func  = saki::return_param, typename saki::enable_if_nullptr_t&lt; std::is_arithmetic_v&lt; T &gt; &amp;&amp;std::is_invocable_v&lt; Func, T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac51e06f83630682641e0d99d5c957a9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac51e06f83630682641e0d99d5c957a9c">sigma</a> (T start, const T &amp;end, Func &amp;&amp;f=Func())</td></tr>
<tr class="memdesc:ac51e06f83630682641e0d99d5c957a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">数学のシグマを簡単に実装  <a href="#ac51e06f83630682641e0d99d5c957a9c">[詳解]</a><br /></td></tr>
<tr class="separator:ac51e06f83630682641e0d99d5c957a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed78463ed5808788e1b77eeecd9352a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ed78463ed5808788e1b77eeecd9352a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5ed78463ed5808788e1b77eeecd9352a">signbit</a> (T x)</td></tr>
<tr class="memdesc:a5ed78463ed5808788e1b77eeecd9352a"><td class="mdescLeft">&#160;</td><td class="mdescRight">負数かどうか判定する  <a href="#a5ed78463ed5808788e1b77eeecd9352a">[詳解]</a><br /></td></tr>
<tr class="separator:a5ed78463ed5808788e1b77eeecd9352a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743f7284cdebb6406db9b37e42bcd730"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a743f7284cdebb6406db9b37e42bcd730"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a743f7284cdebb6406db9b37e42bcd730">sin</a> (T x)</td></tr>
<tr class="memdesc:a743f7284cdebb6406db9b37e42bcd730"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時sin  <a href="#a743f7284cdebb6406db9b37e42bcd730">[詳解]</a><br /></td></tr>
<tr class="separator:a743f7284cdebb6406db9b37e42bcd730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd77d1e52189e28f4a5d069891501cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a9fd77d1e52189e28f4a5d069891501cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a9fd77d1e52189e28f4a5d069891501cf">sin</a> (T x)</td></tr>
<tr class="memdesc:a9fd77d1e52189e28f4a5d069891501cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a9fd77d1e52189e28f4a5d069891501cf">[詳解]</a><br /></td></tr>
<tr class="separator:a9fd77d1e52189e28f4a5d069891501cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1ef6db83d59a5eb2daac9bff09d312"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:abe1ef6db83d59a5eb2daac9bff09d312"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abe1ef6db83d59a5eb2daac9bff09d312">sinh</a> (T x)</td></tr>
<tr class="memdesc:abe1ef6db83d59a5eb2daac9bff09d312"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時sinh  <a href="#abe1ef6db83d59a5eb2daac9bff09d312">[詳解]</a><br /></td></tr>
<tr class="separator:abe1ef6db83d59a5eb2daac9bff09d312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8199390b7650fdebe491aaeb4c3a44c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a8199390b7650fdebe491aaeb4c3a44c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8199390b7650fdebe491aaeb4c3a44c3">sinh</a> (T x)</td></tr>
<tr class="memdesc:a8199390b7650fdebe491aaeb4c3a44c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a8199390b7650fdebe491aaeb4c3a44c3">[詳解]</a><br /></td></tr>
<tr class="separator:a8199390b7650fdebe491aaeb4c3a44c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2f6c98a144d6ba6683c86c865fd595"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a5c2f6c98a144d6ba6683c86c865fd595"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5c2f6c98a144d6ba6683c86c865fd595">sqrt</a> (T x)</td></tr>
<tr class="memdesc:a5c2f6c98a144d6ba6683c86c865fd595"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時平方根  <a href="#a5c2f6c98a144d6ba6683c86c865fd595">[詳解]</a><br /></td></tr>
<tr class="separator:a5c2f6c98a144d6ba6683c86c865fd595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fac13294984ad19b8b7fec3b5466b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a66fac13294984ad19b8b7fec3b5466b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a66fac13294984ad19b8b7fec3b5466b5">sqrt</a> (T x)</td></tr>
<tr class="memdesc:a66fac13294984ad19b8b7fec3b5466b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a66fac13294984ad19b8b7fec3b5466b5">[詳解]</a><br /></td></tr>
<tr class="separator:a66fac13294984ad19b8b7fec3b5466b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491321db8475898649b625dca5401726"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a491321db8475898649b625dca5401726"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a491321db8475898649b625dca5401726">tan</a> (T x)</td></tr>
<tr class="memdesc:a491321db8475898649b625dca5401726"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時tan  <a href="#a491321db8475898649b625dca5401726">[詳解]</a><br /></td></tr>
<tr class="separator:a491321db8475898649b625dca5401726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52704083849bbdf4ab635cca985c00ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a52704083849bbdf4ab635cca985c00ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a52704083849bbdf4ab635cca985c00ae">tan</a> (T x)</td></tr>
<tr class="memdesc:a52704083849bbdf4ab635cca985c00ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a52704083849bbdf4ab635cca985c00ae">[詳解]</a><br /></td></tr>
<tr class="separator:a52704083849bbdf4ab635cca985c00ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2674216630169ce211f8076492ce14e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:af2674216630169ce211f8076492ce14e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af2674216630169ce211f8076492ce14e">tanh</a> (T x)</td></tr>
<tr class="memdesc:af2674216630169ce211f8076492ce14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイル時tanh  <a href="#af2674216630169ce211f8076492ce14e">[詳解]</a><br /></td></tr>
<tr class="separator:af2674216630169ce211f8076492ce14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf83bc9a4a7e981275deba551d2f3f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a5faf83bc9a4a7e981275deba551d2f3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5faf83bc9a4a7e981275deba551d2f3f">tanh</a> (T x)</td></tr>
<tr class="memdesc:a5faf83bc9a4a7e981275deba551d2f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数がint型の場合に、戻り値をdouble型にするためのもの  <a href="#a5faf83bc9a4a7e981275deba551d2f3f">[詳解]</a><br /></td></tr>
<tr class="separator:a5faf83bc9a4a7e981275deba551d2f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2311e77a2bed9d914a6b3e8056d6023a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2311e77a2bed9d914a6b3e8056d6023a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a2311e77a2bed9d914a6b3e8056d6023a">translate</a> (const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a2311e77a2bed9d914a6b3e8056d6023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">平行移動  <a href="#a2311e77a2bed9d914a6b3e8056d6023a">[詳解]</a><br /></td></tr>
<tr class="separator:a2311e77a2bed9d914a6b3e8056d6023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492418470fa4dedb2065e7916460f0e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a492418470fa4dedb2065e7916460f0e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a492418470fa4dedb2065e7916460f0e0">translate</a> (const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a492418470fa4dedb2065e7916460f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">平行移動  <a href="#a492418470fa4dedb2065e7916460f0e0">[詳解]</a><br /></td></tr>
<tr class="separator:a492418470fa4dedb2065e7916460f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd23c2e56d1500ae2e8b662c5ddcf7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdd23c2e56d1500ae2e8b662c5ddcf7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abdd23c2e56d1500ae2e8b662c5ddcf7c">translate</a> (const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:abdd23c2e56d1500ae2e8b662c5ddcf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">平行移動  <a href="#abdd23c2e56d1500ae2e8b662c5ddcf7c">[詳解]</a><br /></td></tr>
<tr class="separator:abdd23c2e56d1500ae2e8b662c5ddcf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda5ab30bf4dc9240857d62d56e590f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abda5ab30bf4dc9240857d62d56e590f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abda5ab30bf4dc9240857d62d56e590f9">scaling</a> (const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:abda5ab30bf4dc9240857d62d56e590f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡縮  <a href="#abda5ab30bf4dc9240857d62d56e590f9">[詳解]</a><br /></td></tr>
<tr class="separator:abda5ab30bf4dc9240857d62d56e590f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcd920fe27abc17e5fa50f04bfabe05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affcd920fe27abc17e5fa50f04bfabe05"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#affcd920fe27abc17e5fa50f04bfabe05">scaling</a> (const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:affcd920fe27abc17e5fa50f04bfabe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡縮  <a href="#affcd920fe27abc17e5fa50f04bfabe05">[詳解]</a><br /></td></tr>
<tr class="separator:affcd920fe27abc17e5fa50f04bfabe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aededd0f357c48d1e96af77b06cb3e786"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aededd0f357c48d1e96af77b06cb3e786"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aededd0f357c48d1e96af77b06cb3e786">scaling</a> (const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:aededd0f357c48d1e96af77b06cb3e786"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡縮  <a href="#aededd0f357c48d1e96af77b06cb3e786">[詳解]</a><br /></td></tr>
<tr class="separator:aededd0f357c48d1e96af77b06cb3e786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eb3090250dfcb43dd1c7579b6b473c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a10eb3090250dfcb43dd1c7579b6b473c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a10eb3090250dfcb43dd1c7579b6b473c">operator+</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a10eb3090250dfcb43dd1c7579b6b473c"><td class="mdescLeft">&#160;</td><td class="mdescRight">+演算子  <a href="#a10eb3090250dfcb43dd1c7579b6b473c">[詳解]</a><br /></td></tr>
<tr class="separator:a10eb3090250dfcb43dd1c7579b6b473c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7474901f1f0d3a80142ed713b75ed5e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa7474901f1f0d3a80142ed713b75ed5e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa7474901f1f0d3a80142ed713b75ed5e">operator-</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:aa7474901f1f0d3a80142ed713b75ed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">-演算子  <a href="#aa7474901f1f0d3a80142ed713b75ed5e">[詳解]</a><br /></td></tr>
<tr class="separator:aa7474901f1f0d3a80142ed713b75ed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec94b07795582554759e6f844b6055f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8ec94b07795582554759e6f844b6055f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8ec94b07795582554759e6f844b6055f">operator*</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:a8ec94b07795582554759e6f844b6055f"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(行列*スカラ)  <a href="#a8ec94b07795582554759e6f844b6055f">[詳解]</a><br /></td></tr>
<tr class="separator:a8ec94b07795582554759e6f844b6055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d16324180fd378c3636f9bd961d20"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acc7d16324180fd378c3636f9bd961d20"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#acc7d16324180fd378c3636f9bd961d20">operator*</a> (const T1 &amp;scalar, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;m)</td></tr>
<tr class="memdesc:acc7d16324180fd378c3636f9bd961d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(スカラ*行列)  <a href="#acc7d16324180fd378c3636f9bd961d20">[詳解]</a><br /></td></tr>
<tr class="separator:acc7d16324180fd378c3636f9bd961d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d9d53f473cbaa176e97500ea9ee491"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae7d9d53f473cbaa176e97500ea9ee491"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ae7d9d53f473cbaa176e97500ea9ee491">operator*</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:ae7d9d53f473cbaa176e97500ea9ee491"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(行列*行列)  <a href="#ae7d9d53f473cbaa176e97500ea9ee491">[詳解]</a><br /></td></tr>
<tr class="separator:ae7d9d53f473cbaa176e97500ea9ee491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69ad44a115a64e5874921344c34d62e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac69ad44a115a64e5874921344c34d62e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac69ad44a115a64e5874921344c34d62e">operator/</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:ac69ad44a115a64e5874921344c34d62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(スカラ)  <a href="#ac69ad44a115a64e5874921344c34d62e">[詳解]</a><br /></td></tr>
<tr class="separator:ac69ad44a115a64e5874921344c34d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e5e15cae6e9152e0bd5ac2e1705da4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67e5e15cae6e9152e0bd5ac2e1705da4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a67e5e15cae6e9152e0bd5ac2e1705da4">operator==</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;m2)</td></tr>
<tr class="memdesc:a67e5e15cae6e9152e0bd5ac2e1705da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子  <a href="#a67e5e15cae6e9152e0bd5ac2e1705da4">[詳解]</a><br /></td></tr>
<tr class="separator:a67e5e15cae6e9152e0bd5ac2e1705da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76722addb100e11d9eb9370ced3b027c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76722addb100e11d9eb9370ced3b027c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a76722addb100e11d9eb9370ced3b027c">operator!=</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;m2)</td></tr>
<tr class="memdesc:a76722addb100e11d9eb9370ced3b027c"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子  <a href="#a76722addb100e11d9eb9370ced3b027c">[詳解]</a><br /></td></tr>
<tr class="separator:a76722addb100e11d9eb9370ced3b027c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffbf8122dda5209dc384e64747bec32"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1ffbf8122dda5209dc384e64747bec32"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a1ffbf8122dda5209dc384e64747bec32">operator==</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a1ffbf8122dda5209dc384e64747bec32"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子(型不一致)  <a href="#a1ffbf8122dda5209dc384e64747bec32">[詳解]</a><br /></td></tr>
<tr class="separator:a1ffbf8122dda5209dc384e64747bec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bef07cf55a40a115c89e6e20406b124"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4bef07cf55a40a115c89e6e20406b124"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a4bef07cf55a40a115c89e6e20406b124">operator!=</a> (const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;m1, const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a4bef07cf55a40a115c89e6e20406b124"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子(型不一致)  <a href="#a4bef07cf55a40a115c89e6e20406b124">[詳解]</a><br /></td></tr>
<tr class="separator:a4bef07cf55a40a115c89e6e20406b124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2ea69ef5e31c8004ba36bb10384333"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename BinaryOperation  = saki::addition, typename T  = saki::remove_reference_const_t&lt;typename Container::value_type&gt;, typename saki::enable_if_nullptr_t&lt; saki::can_range_based_for_v&lt; Container &gt; &amp;&amp;std::is_invocable_r_v&lt; T, BinaryOperation, T, T &gt; &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a6f2ea69ef5e31c8004ba36bb10384333"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a6f2ea69ef5e31c8004ba36bb10384333">accumulate</a> (const Container &amp;con, T init=0, BinaryOperation &amp;&amp;binary_op=<a class="el" href="structsaki_1_1addition.html">saki::addition</a>())</td></tr>
<tr class="memdesc:a6f2ea69ef5e31c8004ba36bb10384333"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数が2つの関数を指定し、それをすべての要素で回す  <a href="#a6f2ea69ef5e31c8004ba36bb10384333">[詳解]</a><br /></td></tr>
<tr class="separator:a6f2ea69ef5e31c8004ba36bb10384333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636caf16f2f00cb734cc867646ac233f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a636caf16f2f00cb734cc867646ac233f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a636caf16f2f00cb734cc867646ac233f">random</a> (const T random_min, const T random_max)</td></tr>
<tr class="memdesc:a636caf16f2f00cb734cc867646ac233f"><td class="mdescLeft">&#160;</td><td class="mdescRight">最小値と最大値を引数にとり、その間からランダムな値を返す  <a href="#a636caf16f2f00cb734cc867646ac233f">[詳解]</a><br /></td></tr>
<tr class="separator:a636caf16f2f00cb734cc867646ac233f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15185db28f6e77d65411ca83f64f5bb"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename &gt; typename Container = std::vector, typename T , typename saki::enable_if_nullptr_t&lt; saki::has_check_v&lt; T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad15185db28f6e77d65411ca83f64f5bb"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; std::string, std::allocator&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ad15185db28f6e77d65411ca83f64f5bb">split</a> (const std::string &amp;str, T &amp;&amp;split_separation)</td></tr>
<tr class="memdesc:ad15185db28f6e77d65411ca83f64f5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">string型を指定された文字で区切ったものをvectorで返す  <a href="#ad15185db28f6e77d65411ca83f64f5bb">[詳解]</a><br /></td></tr>
<tr class="separator:ad15185db28f6e77d65411ca83f64f5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1464436ac78ade2ba14371e2efe1fd2"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename &gt; typename Container = std::vector, typename First , typename ... T&gt; </td></tr>
<tr class="memitem:ac1464436ac78ade2ba14371e2efe1fd2"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; std::string, std::allocator&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac1464436ac78ade2ba14371e2efe1fd2">split</a> (const std::string &amp;str, First first_separation, T ...t)</td></tr>
<tr class="memdesc:ac1464436ac78ade2ba14371e2efe1fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">string型を指定された文字で区切ったものをvectorで返す  <a href="#ac1464436ac78ade2ba14371e2efe1fd2">[詳解]</a><br /></td></tr>
<tr class="separator:ac1464436ac78ade2ba14371e2efe1fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf390d4e6c19fdb92d3a68afb7e71032"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:abf390d4e6c19fdb92d3a68afb7e71032"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abf390d4e6c19fdb92d3a68afb7e71032">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsaki_1_1string__base.html">string_base</a>&lt; T, N &gt; &amp;str)</td></tr>
<tr class="memdesc:abf390d4e6c19fdb92d3a68afb7e71032"><td class="mdescLeft">&#160;</td><td class="mdescRight">stringの出力  <a href="#abf390d4e6c19fdb92d3a68afb7e71032">[詳解]</a><br /></td></tr>
<tr class="separator:abf390d4e6c19fdb92d3a68afb7e71032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a09941a80893dfdea6da4c220fba08"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Integer , size_t N = saki::digit_count(std::numeric_limits&lt;Integer&gt;::max()) + 1, typename StringType  = saki::string_base&lt;T, N&gt;, typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; Integer &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a52a09941a80893dfdea6da4c220fba08"><td class="memTemplItemLeft" align="right" valign="top">constexpr StringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a52a09941a80893dfdea6da4c220fba08">int_to_string</a> (Integer x)</td></tr>
<tr class="memdesc:a52a09941a80893dfdea6da4c220fba08"><td class="mdescLeft">&#160;</td><td class="mdescRight">int型からstring型に変換  <a href="#a52a09941a80893dfdea6da4c220fba08">[詳解]</a><br /></td></tr>
<tr class="separator:a52a09941a80893dfdea6da4c220fba08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f643bf5bc8002b1fefb916ff9c1d56a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8f643bf5bc8002b1fefb916ff9c1d56a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8f643bf5bc8002b1fefb916ff9c1d56a">operator+</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a8f643bf5bc8002b1fefb916ff9c1d56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">+演算子  <a href="#a8f643bf5bc8002b1fefb916ff9c1d56a">[詳解]</a><br /></td></tr>
<tr class="separator:a8f643bf5bc8002b1fefb916ff9c1d56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8b351ef2a4ccd991bc774540619b3a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1a8b351ef2a4ccd991bc774540619b3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a1a8b351ef2a4ccd991bc774540619b3a">operator-</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a1a8b351ef2a4ccd991bc774540619b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">-演算子  <a href="#a1a8b351ef2a4ccd991bc774540619b3a">[詳解]</a><br /></td></tr>
<tr class="separator:a1a8b351ef2a4ccd991bc774540619b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9612151e27555ea59013c6a7da3322d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab9612151e27555ea59013c6a7da3322d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab9612151e27555ea59013c6a7da3322d">operator*</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:ab9612151e27555ea59013c6a7da3322d"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(transform*スカラ)  <a href="#ab9612151e27555ea59013c6a7da3322d">[詳解]</a><br /></td></tr>
<tr class="separator:ab9612151e27555ea59013c6a7da3322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06bb4644df2b78c5032c0656472d4c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9f06bb4644df2b78c5032c0656472d4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a9f06bb4644df2b78c5032c0656472d4c">operator*</a> (const T1 &amp;scalar, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;v)</td></tr>
<tr class="memdesc:a9f06bb4644df2b78c5032c0656472d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(スカラ*transform)  <a href="#a9f06bb4644df2b78c5032c0656472d4c">[詳解]</a><br /></td></tr>
<tr class="separator:a9f06bb4644df2b78c5032c0656472d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae41cae2f869873e083124ad5f1b5f67"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aae41cae2f869873e083124ad5f1b5f67"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aae41cae2f869873e083124ad5f1b5f67">operator/</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:aae41cae2f869873e083124ad5f1b5f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(スカラ)  <a href="#aae41cae2f869873e083124ad5f1b5f67">[詳解]</a><br /></td></tr>
<tr class="separator:aae41cae2f869873e083124ad5f1b5f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a23952c9becf92a51ff1742f645d66"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57a23952c9becf92a51ff1742f645d66"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a57a23952c9becf92a51ff1742f645d66">operator==</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a57a23952c9becf92a51ff1742f645d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子  <a href="#a57a23952c9becf92a51ff1742f645d66">[詳解]</a><br /></td></tr>
<tr class="separator:a57a23952c9becf92a51ff1742f645d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91b2b2e47f5556c7604281af5223247"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af91b2b2e47f5556c7604281af5223247"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af91b2b2e47f5556c7604281af5223247">operator!=</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:af91b2b2e47f5556c7604281af5223247"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子  <a href="#af91b2b2e47f5556c7604281af5223247">[詳解]</a><br /></td></tr>
<tr class="separator:af91b2b2e47f5556c7604281af5223247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7d962261485c2054cd1a98ed337ed"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:afde7d962261485c2054cd1a98ed337ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#afde7d962261485c2054cd1a98ed337ed">operator==</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:afde7d962261485c2054cd1a98ed337ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子(型不一致)  <a href="#afde7d962261485c2054cd1a98ed337ed">[詳解]</a><br /></td></tr>
<tr class="separator:afde7d962261485c2054cd1a98ed337ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c33f5cbcafab48779b77c324716fed9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8c33f5cbcafab48779b77c324716fed9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8c33f5cbcafab48779b77c324716fed9">operator!=</a> (const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a8c33f5cbcafab48779b77c324716fed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子(型不一致)  <a href="#a8c33f5cbcafab48779b77c324716fed9">[詳解]</a><br /></td></tr>
<tr class="separator:a8c33f5cbcafab48779b77c324716fed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c132b30fc5554123e166c29a5292607"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7c132b30fc5554123e166c29a5292607"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7c132b30fc5554123e166c29a5292607">operator+</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a7c132b30fc5554123e166c29a5292607"><td class="mdescLeft">&#160;</td><td class="mdescRight">+演算子  <a href="#a7c132b30fc5554123e166c29a5292607">[詳解]</a><br /></td></tr>
<tr class="separator:a7c132b30fc5554123e166c29a5292607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08546185e6a03ba6496daf21d943799"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab08546185e6a03ba6496daf21d943799"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab08546185e6a03ba6496daf21d943799">operator-</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ab08546185e6a03ba6496daf21d943799"><td class="mdescLeft">&#160;</td><td class="mdescRight">-演算子  <a href="#ab08546185e6a03ba6496daf21d943799">[詳解]</a><br /></td></tr>
<tr class="separator:ab08546185e6a03ba6496daf21d943799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6668922b972ec01303867612e4783"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af6d6668922b972ec01303867612e4783"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af6d6668922b972ec01303867612e4783">operator*</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:af6d6668922b972ec01303867612e4783"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(ベクトル*スカラ)  <a href="#af6d6668922b972ec01303867612e4783">[詳解]</a><br /></td></tr>
<tr class="separator:af6d6668922b972ec01303867612e4783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5d04727e813b089aadf4b97247b64a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7d5d04727e813b089aadf4b97247b64a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a7d5d04727e813b089aadf4b97247b64a">operator*</a> (const T1 &amp;scalar, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v)</td></tr>
<tr class="memdesc:a7d5d04727e813b089aadf4b97247b64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(スカラ*ベクトル)  <a href="#a7d5d04727e813b089aadf4b97247b64a">[詳解]</a><br /></td></tr>
<tr class="separator:a7d5d04727e813b089aadf4b97247b64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db47b2e2e0826325ae66ee6216ba5fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1db47b2e2e0826325ae66ee6216ba5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a1db47b2e2e0826325ae66ee6216ba5fc">operator*</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a1db47b2e2e0826325ae66ee6216ba5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(ベクトル)  <a href="#a1db47b2e2e0826325ae66ee6216ba5fc">[詳解]</a><br /></td></tr>
<tr class="separator:a1db47b2e2e0826325ae66ee6216ba5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12f7d971656317d7e0502bf64fe762a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab12f7d971656317d7e0502bf64fe762a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab12f7d971656317d7e0502bf64fe762a">operator/</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:ab12f7d971656317d7e0502bf64fe762a"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(スカラ)  <a href="#ab12f7d971656317d7e0502bf64fe762a">[詳解]</a><br /></td></tr>
<tr class="separator:ab12f7d971656317d7e0502bf64fe762a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af613b8219c84ed98901c66a082938a61"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af613b8219c84ed98901c66a082938a61"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af613b8219c84ed98901c66a082938a61">operator/</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:af613b8219c84ed98901c66a082938a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(ベクトル)  <a href="#af613b8219c84ed98901c66a082938a61">[詳解]</a><br /></td></tr>
<tr class="separator:af613b8219c84ed98901c66a082938a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aafc5056183a1a522b89497ee3439e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2aafc5056183a1a522b89497ee3439e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a2aafc5056183a1a522b89497ee3439e9">operator==</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a2aafc5056183a1a522b89497ee3439e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子  <a href="#a2aafc5056183a1a522b89497ee3439e9">[詳解]</a><br /></td></tr>
<tr class="separator:a2aafc5056183a1a522b89497ee3439e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c806d3237b6718e95e9b71f838bcc1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0c806d3237b6718e95e9b71f838bcc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac0c806d3237b6718e95e9b71f838bcc1">operator!=</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:ac0c806d3237b6718e95e9b71f838bcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子  <a href="#ac0c806d3237b6718e95e9b71f838bcc1">[詳解]</a><br /></td></tr>
<tr class="separator:ac0c806d3237b6718e95e9b71f838bcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07efea0cf7385fc13c00519e8f0f7732"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a07efea0cf7385fc13c00519e8f0f7732"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a07efea0cf7385fc13c00519e8f0f7732">operator==</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a07efea0cf7385fc13c00519e8f0f7732"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子(型不一致)  <a href="#a07efea0cf7385fc13c00519e8f0f7732">[詳解]</a><br /></td></tr>
<tr class="separator:a07efea0cf7385fc13c00519e8f0f7732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7159e145464e2deab2de2a76be1c00"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0d7159e145464e2deab2de2a76be1c00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a0d7159e145464e2deab2de2a76be1c00">operator!=</a> (const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a0d7159e145464e2deab2de2a76be1c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子(型不一致)  <a href="#a0d7159e145464e2deab2de2a76be1c00">[詳解]</a><br /></td></tr>
<tr class="separator:a0d7159e145464e2deab2de2a76be1c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eb9872710ab7ebca5e7a665f1a7cd7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af2eb9872710ab7ebca5e7a665f1a7cd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af2eb9872710ab7ebca5e7a665f1a7cd7">operator+</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:af2eb9872710ab7ebca5e7a665f1a7cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">+演算子  <a href="#af2eb9872710ab7ebca5e7a665f1a7cd7">[詳解]</a><br /></td></tr>
<tr class="separator:af2eb9872710ab7ebca5e7a665f1a7cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8697755777c25ac12687ea8804f80331"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8697755777c25ac12687ea8804f80331"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a8697755777c25ac12687ea8804f80331">operator-</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a8697755777c25ac12687ea8804f80331"><td class="mdescLeft">&#160;</td><td class="mdescRight">-演算子  <a href="#a8697755777c25ac12687ea8804f80331">[詳解]</a><br /></td></tr>
<tr class="separator:a8697755777c25ac12687ea8804f80331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9716c5a5ccdc1cafb975df8897acb3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:abd9716c5a5ccdc1cafb975df8897acb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abd9716c5a5ccdc1cafb975df8897acb3">operator*</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:abd9716c5a5ccdc1cafb975df8897acb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(ベクトル*スカラ)  <a href="#abd9716c5a5ccdc1cafb975df8897acb3">[詳解]</a><br /></td></tr>
<tr class="separator:abd9716c5a5ccdc1cafb975df8897acb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e41594237dcaac47a2a27ed97f48f6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab3e41594237dcaac47a2a27ed97f48f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ab3e41594237dcaac47a2a27ed97f48f6">operator*</a> (const T1 &amp;scalar, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v)</td></tr>
<tr class="memdesc:ab3e41594237dcaac47a2a27ed97f48f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(スカラ*ベクトル)  <a href="#ab3e41594237dcaac47a2a27ed97f48f6">[詳解]</a><br /></td></tr>
<tr class="separator:ab3e41594237dcaac47a2a27ed97f48f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d261ceb3780fa55acc164671b67992"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a59d261ceb3780fa55acc164671b67992"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a59d261ceb3780fa55acc164671b67992">operator*</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a59d261ceb3780fa55acc164671b67992"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(ベクトル)  <a href="#a59d261ceb3780fa55acc164671b67992">[詳解]</a><br /></td></tr>
<tr class="separator:a59d261ceb3780fa55acc164671b67992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15270d7bd5638726debe317a16a6b26b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a15270d7bd5638726debe317a16a6b26b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a15270d7bd5638726debe317a16a6b26b">operator/</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:a15270d7bd5638726debe317a16a6b26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(スカラ)  <a href="#a15270d7bd5638726debe317a16a6b26b">[詳解]</a><br /></td></tr>
<tr class="separator:a15270d7bd5638726debe317a16a6b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee335c88f00f71e52e37fd4bfb77b181"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aee335c88f00f71e52e37fd4bfb77b181"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aee335c88f00f71e52e37fd4bfb77b181">operator/</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:aee335c88f00f71e52e37fd4bfb77b181"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(ベクトル)  <a href="#aee335c88f00f71e52e37fd4bfb77b181">[詳解]</a><br /></td></tr>
<tr class="separator:aee335c88f00f71e52e37fd4bfb77b181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce1faca02399d52a09851a1b6e8afe3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ce1faca02399d52a09851a1b6e8afe3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a3ce1faca02399d52a09851a1b6e8afe3">operator==</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a3ce1faca02399d52a09851a1b6e8afe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子  <a href="#a3ce1faca02399d52a09851a1b6e8afe3">[詳解]</a><br /></td></tr>
<tr class="separator:a3ce1faca02399d52a09851a1b6e8afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b0dcab7f268e88f01c92c95cd12135"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8b0dcab7f268e88f01c92c95cd12135"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa8b0dcab7f268e88f01c92c95cd12135">operator!=</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:aa8b0dcab7f268e88f01c92c95cd12135"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子  <a href="#aa8b0dcab7f268e88f01c92c95cd12135">[詳解]</a><br /></td></tr>
<tr class="separator:aa8b0dcab7f268e88f01c92c95cd12135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3eb3ebd6a3ee43771849069101153f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5f3eb3ebd6a3ee43771849069101153f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5f3eb3ebd6a3ee43771849069101153f">operator==</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a5f3eb3ebd6a3ee43771849069101153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子(型不一致)  <a href="#a5f3eb3ebd6a3ee43771849069101153f">[詳解]</a><br /></td></tr>
<tr class="separator:a5f3eb3ebd6a3ee43771849069101153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8393ad670f8bb199a92d4287bb1bf3a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae8393ad670f8bb199a92d4287bb1bf3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ae8393ad670f8bb199a92d4287bb1bf3a">operator!=</a> (const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ae8393ad670f8bb199a92d4287bb1bf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子(型不一致)  <a href="#ae8393ad670f8bb199a92d4287bb1bf3a">[詳解]</a><br /></td></tr>
<tr class="separator:ae8393ad670f8bb199a92d4287bb1bf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba02830a0fe4fd92a264f80bd5f6cd65"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aba02830a0fe4fd92a264f80bd5f6cd65"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aba02830a0fe4fd92a264f80bd5f6cd65">operator+</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:aba02830a0fe4fd92a264f80bd5f6cd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">+演算子  <a href="#aba02830a0fe4fd92a264f80bd5f6cd65">[詳解]</a><br /></td></tr>
<tr class="separator:aba02830a0fe4fd92a264f80bd5f6cd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9369c0656bd3b8b940eadf027b41f3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9b9369c0656bd3b8b940eadf027b41f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a9b9369c0656bd3b8b940eadf027b41f3">operator-</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a9b9369c0656bd3b8b940eadf027b41f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">-演算子  <a href="#a9b9369c0656bd3b8b940eadf027b41f3">[詳解]</a><br /></td></tr>
<tr class="separator:a9b9369c0656bd3b8b940eadf027b41f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe5418c09468a2435c0a8a85a941174"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0fe5418c09468a2435c0a8a85a941174"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a0fe5418c09468a2435c0a8a85a941174">operator*</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:a0fe5418c09468a2435c0a8a85a941174"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(ベクトル*スカラ)  <a href="#a0fe5418c09468a2435c0a8a85a941174">[詳解]</a><br /></td></tr>
<tr class="separator:a0fe5418c09468a2435c0a8a85a941174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1caaaf5b1af879f2d546a4b2e10974e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad1caaaf5b1af879f2d546a4b2e10974e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ad1caaaf5b1af879f2d546a4b2e10974e">operator*</a> (const T1 &amp;scalar, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v)</td></tr>
<tr class="memdesc:ad1caaaf5b1af879f2d546a4b2e10974e"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(スカラ*ベクトル)  <a href="#ad1caaaf5b1af879f2d546a4b2e10974e">[詳解]</a><br /></td></tr>
<tr class="separator:ad1caaaf5b1af879f2d546a4b2e10974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19656e376d8720e2a67f3d08082770b0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a19656e376d8720e2a67f3d08082770b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a19656e376d8720e2a67f3d08082770b0">operator*</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a19656e376d8720e2a67f3d08082770b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">*演算子(ベクトル)  <a href="#a19656e376d8720e2a67f3d08082770b0">[詳解]</a><br /></td></tr>
<tr class="separator:a19656e376d8720e2a67f3d08082770b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5525c6da34ded0620ee6d965e687bedc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5525c6da34ded0620ee6d965e687bedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5525c6da34ded0620ee6d965e687bedc">operator/</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v, const T2 &amp;scalar)</td></tr>
<tr class="memdesc:a5525c6da34ded0620ee6d965e687bedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(スカラ)  <a href="#a5525c6da34ded0620ee6d965e687bedc">[詳解]</a><br /></td></tr>
<tr class="separator:a5525c6da34ded0620ee6d965e687bedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72c945dc5e1e8fe6065beac4a310a54"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac72c945dc5e1e8fe6065beac4a310a54"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#ac72c945dc5e1e8fe6065beac4a310a54">operator/</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ac72c945dc5e1e8fe6065beac4a310a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">/演算子(ベクトル)  <a href="#ac72c945dc5e1e8fe6065beac4a310a54">[詳解]</a><br /></td></tr>
<tr class="separator:ac72c945dc5e1e8fe6065beac4a310a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe77ceb7257097320a66f9f182d11111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe77ceb7257097320a66f9f182d11111"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abe77ceb7257097320a66f9f182d11111">operator==</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:abe77ceb7257097320a66f9f182d11111"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子  <a href="#abe77ceb7257097320a66f9f182d11111">[詳解]</a><br /></td></tr>
<tr class="separator:abe77ceb7257097320a66f9f182d11111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6805502ef12cd12f6be61a958fd35aa7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6805502ef12cd12f6be61a958fd35aa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a6805502ef12cd12f6be61a958fd35aa7">operator!=</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6805502ef12cd12f6be61a958fd35aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子  <a href="#a6805502ef12cd12f6be61a958fd35aa7">[詳解]</a><br /></td></tr>
<tr class="separator:a6805502ef12cd12f6be61a958fd35aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a10e5e2974f482b6da75d9137dc143"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af2a10e5e2974f482b6da75d9137dc143"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#af2a10e5e2974f482b6da75d9137dc143">operator==</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:af2a10e5e2974f482b6da75d9137dc143"><td class="mdescLeft">&#160;</td><td class="mdescRight">==演算子(型不一致)  <a href="#af2a10e5e2974f482b6da75d9137dc143">[詳解]</a><br /></td></tr>
<tr class="separator:af2a10e5e2974f482b6da75d9137dc143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f98117a7a12898df59d2041040000"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:abf6f98117a7a12898df59d2041040000"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#abf6f98117a7a12898df59d2041040000">operator!=</a> (const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:abf6f98117a7a12898df59d2041040000"><td class="mdescLeft">&#160;</td><td class="mdescRight">!=演算子(型不一致)  <a href="#abf6f98117a7a12898df59d2041040000">[詳解]</a><br /></td></tr>
<tr class="separator:abf6f98117a7a12898df59d2041040000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca208fb45c585d9cd23276fb91e40ee"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T &gt; </td></tr>
<tr class="memitem:a0ca208fb45c585d9cd23276fb91e40ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a0ca208fb45c585d9cd23276fb91e40ee">normalize</a> (const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a0ca208fb45c585d9cd23276fb91e40ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化  <a href="#a0ca208fb45c585d9cd23276fb91e40ee">[詳解]</a><br /></td></tr>
<tr class="separator:a0ca208fb45c585d9cd23276fb91e40ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820a45ae402c8447bce4fee36a1f7d62"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a820a45ae402c8447bce4fee36a1f7d62"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a820a45ae402c8447bce4fee36a1f7d62">dot</a> (const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a820a45ae402c8447bce4fee36a1f7d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">内積  <a href="#a820a45ae402c8447bce4fee36a1f7d62">[詳解]</a><br /></td></tr>
<tr class="separator:a820a45ae402c8447bce4fee36a1f7d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457d78ffe360e1d8a78d14ec5dab38f2"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a457d78ffe360e1d8a78d14ec5dab38f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a457d78ffe360e1d8a78d14ec5dab38f2">cross</a> (const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a457d78ffe360e1d8a78d14ec5dab38f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">外積  <a href="#a457d78ffe360e1d8a78d14ec5dab38f2">[詳解]</a><br /></td></tr>
<tr class="separator:a457d78ffe360e1d8a78d14ec5dab38f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e4449261f40ee6f47abc49844e66c"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 , typename T  = double&gt; </td></tr>
<tr class="memitem:aca2e4449261f40ee6f47abc49844e66c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aca2e4449261f40ee6f47abc49844e66c">lerp</a> (const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T2 &gt; &amp;v2, const T &amp;t, const T &amp;base=1)</td></tr>
<tr class="memdesc:aca2e4449261f40ee6f47abc49844e66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">線形補間  <a href="#aca2e4449261f40ee6f47abc49844e66c">[詳解]</a><br /></td></tr>
<tr class="separator:aca2e4449261f40ee6f47abc49844e66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38ed490dc1e7d5df7241eefd1c9453b"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T &gt; </td></tr>
<tr class="memitem:aa38ed490dc1e7d5df7241eefd1c9453b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#aa38ed490dc1e7d5df7241eefd1c9453b">normalize</a> (const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa38ed490dc1e7d5df7241eefd1c9453b"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化  <a href="#aa38ed490dc1e7d5df7241eefd1c9453b">[詳解]</a><br /></td></tr>
<tr class="separator:aa38ed490dc1e7d5df7241eefd1c9453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be905d72bf8dc80abc703fe69fa6fec"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5be905d72bf8dc80abc703fe69fa6fec"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a5be905d72bf8dc80abc703fe69fa6fec">dot</a> (const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a5be905d72bf8dc80abc703fe69fa6fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">内積  <a href="#a5be905d72bf8dc80abc703fe69fa6fec">[詳解]</a><br /></td></tr>
<tr class="separator:a5be905d72bf8dc80abc703fe69fa6fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980242869d69e47ff8b10335e86ccf6f"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a980242869d69e47ff8b10335e86ccf6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a980242869d69e47ff8b10335e86ccf6f">cross</a> (const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a980242869d69e47ff8b10335e86ccf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">外積  <a href="#a980242869d69e47ff8b10335e86ccf6f">[詳解]</a><br /></td></tr>
<tr class="separator:a980242869d69e47ff8b10335e86ccf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5233651ca71b38ed5a53ef304e480"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 , typename T  = double&gt; </td></tr>
<tr class="memitem:a1dc5233651ca71b38ed5a53ef304e480"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a1dc5233651ca71b38ed5a53ef304e480">lerp</a> (const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T2 &gt; &amp;v2, const T &amp;t, const T &amp;base=1)</td></tr>
<tr class="memdesc:a1dc5233651ca71b38ed5a53ef304e480"><td class="mdescLeft">&#160;</td><td class="mdescRight">線形補間  <a href="#a1dc5233651ca71b38ed5a53ef304e480">[詳解]</a><br /></td></tr>
<tr class="separator:a1dc5233651ca71b38ed5a53ef304e480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcef74d7e32ef8cf446d075beeed4b41"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T &gt; </td></tr>
<tr class="memitem:afcef74d7e32ef8cf446d075beeed4b41"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#afcef74d7e32ef8cf446d075beeed4b41">normalize</a> (const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:afcef74d7e32ef8cf446d075beeed4b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化  <a href="#afcef74d7e32ef8cf446d075beeed4b41">[詳解]</a><br /></td></tr>
<tr class="separator:afcef74d7e32ef8cf446d075beeed4b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990ff61a01d4cf819df3fe2774842acf"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a990ff61a01d4cf819df3fe2774842acf"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#a990ff61a01d4cf819df3fe2774842acf">dot</a> (const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a990ff61a01d4cf819df3fe2774842acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">内積  <a href="#a990ff61a01d4cf819df3fe2774842acf">[詳解]</a><br /></td></tr>
<tr class="separator:a990ff61a01d4cf819df3fe2774842acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cd6d8e07cbfcd2691c4d9ffe25416"><td class="memTemplParams" colspan="2">template&lt;typename U  = double, typename T1 , typename T2 , typename T  = double&gt; </td></tr>
<tr class="memitem:acc3cd6d8e07cbfcd2691c4d9ffe25416"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesaki.html#acc3cd6d8e07cbfcd2691c4d9ffe25416">lerp</a> (const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T2 &gt; &amp;v2, const T &amp;t, const T &amp;base=1)</td></tr>
<tr class="memdesc:acc3cd6d8e07cbfcd2691c4d9ffe25416"><td class="mdescLeft">&#160;</td><td class="mdescRight">線形補間  <a href="#acc3cd6d8e07cbfcd2691c4d9ffe25416">[詳解]</a><br /></td></tr>
<tr class="separator:acc3cd6d8e07cbfcd2691c4d9ffe25416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">型定義詳解</h2>
<a id="a4c362f5119aac94085eab0bf794facf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c362f5119aac94085eab0bf794facf7">&#9670;&nbsp;</a></span>enable_if_nullptr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Con&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesaki.html#a4c362f5119aac94085eab0bf794facf7">saki::enable_if_nullptr_t</a> = typedef typename <a class="el" href="structsaki_1_1enable__if__nullptr.html">enable_if_nullptr</a>&lt;Con&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable_if_nullptrを簡単に呼び出せる変数 </p>

</div>
</div>
<a id="aff6964622fdfcdf489dab4b87727a8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6964622fdfcdf489dab4b87727a8e4">&#9670;&nbsp;</a></span>remove_reference_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesaki.html#aff6964622fdfcdf489dab4b87727a8e4">saki::remove_reference_const_t</a> = typedef typename <a class="el" href="structsaki_1_1remove__reference__const.html">saki::remove_reference_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove_reference_constを簡単に呼び出せるようにした </p>

</div>
</div>
<a id="a47847d63f1d9c97ca37f33eeecb27674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47847d63f1d9c97ca37f33eeecb27674">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesaki.html#a47847d63f1d9c97ca37f33eeecb27674">saki::string</a> = typedef <a class="el" href="classsaki_1_1string__base.html">saki::string_base</a>&lt;char, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a37cd607ad87b208aa6105b5d8287dc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cd607ad87b208aa6105b5d8287dc9e">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt;!std::is_unsigned_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時絶対値 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>絶対値を求める値</td></tr>
  </table>
  </dd>
</dl>
<p>符号あり</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>絶対値を求める値</td></tr>
  </table>
  </dd>
</dl>
<p>符号なし </p>

</div>
</div>
<a id="a6f2ea69ef5e31c8004ba36bb10384333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2ea69ef5e31c8004ba36bb10384333">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename BinaryOperation  = saki::addition, typename T  = saki::remove_reference_const_t&lt;typename Container::value_type&gt;, typename saki::enable_if_nullptr_t&lt; saki::can_range_based_for_v&lt; Container &gt; &amp;&amp;std::is_invocable_r_v&lt; T, BinaryOperation, T, T &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::accumulate </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em> = <code><a class="el" href="structsaki_1_1addition.html">saki::addition</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数が2つの関数を指定し、それをすべての要素で回す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>コンテナクラス </td></tr>
    <tr><td class="paramname">init</td><td>初期値 </td></tr>
    <tr><td class="paramname">binary_op</td><td>引数が2つの関数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>全ての要素を回した結果 </dd></dl>

</div>
</div>
<a id="a3189b75c5c7ecbf6d2204142da5fa813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3189b75c5c7ecbf6d2204142da5fa813">&#9670;&nbsp;</a></span>acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::acos </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時acos </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>辺の比 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cad65bf92f361b4b564268af96a7844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cad65bf92f361b4b564268af96a7844">&#9670;&nbsp;</a></span>acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::acos </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int型の比 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c85a4defc25dc9eb6b380f29946f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c85a4defc25dc9eb6b380f29946f83">&#9670;&nbsp;</a></span>acosh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::acosh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時sinh </p>

</div>
</div>
<a id="a8d3766d425082661e966b04504b90002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3766d425082661e966b04504b90002">&#9670;&nbsp;</a></span>acosh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::acosh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a63f2b40515cd62b037dade64aa8465db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f2b40515cd62b037dade64aa8465db">&#9670;&nbsp;</a></span>asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::asin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時asin </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>辺の比 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac285debedd1f53761a838c0e4f57af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac285debedd1f53761a838c0e4f57af0">&#9670;&nbsp;</a></span>asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::asin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int型の比 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab097a2d600f313b6bdd3099e61a10b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097a2d600f313b6bdd3099e61a10b9e">&#9670;&nbsp;</a></span>asinh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::asinh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時asinh </p>

</div>
</div>
<a id="aac840ca5d9b98ac0a8c5b15752f02072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac840ca5d9b98ac0a8c5b15752f02072">&#9670;&nbsp;</a></span>asinh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::asinh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a524b9439c745f69bd8a8b681b03b4b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524b9439c745f69bd8a8b681b03b4b01">&#9670;&nbsp;</a></span>atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::atan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時atan </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>辺の比 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd8a08085fc9210a4e8d61f6c04febe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8a08085fc9210a4e8d61f6c04febe2">&#9670;&nbsp;</a></span>atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::atan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int型の比 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac528a4ab6013623bfe6257229e302015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac528a4ab6013623bfe6257229e302015">&#9670;&nbsp;</a></span>atan2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::atan2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時atan2 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">y,x</td><td>辺の長さ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f8c6dc6223b790f6d227c8d22cf8b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8c6dc6223b790f6d227c8d22cf8b86">&#9670;&nbsp;</a></span>atan2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::atan2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a5c656a9f2a0c0cfe522fb95ac37128cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c656a9f2a0c0cfe522fb95ac37128cc">&#9670;&nbsp;</a></span>atan2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::atan2 </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>型をそろえる </p>

</div>
</div>
<a id="adbfceeab527c51676d00fae31e077dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfceeab527c51676d00fae31e077dcf">&#9670;&nbsp;</a></span>atanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::atanh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時atanh </p>

</div>
</div>
<a id="a1b7d87f99b61600e1201b10de467200f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d87f99b61600e1201b10de467200f">&#9670;&nbsp;</a></span>atanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::atanh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a8836c929b71a61cf0151d3b76eb7af15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8836c929b71a61cf0151d3b76eb7af15">&#9670;&nbsp;</a></span>cbrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::cbrt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時cbrt </p>

</div>
</div>
<a id="a5a3d1ab0508dcff1fb2e17a4ef8a855d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3d1ab0508dcff1fb2e17a4ef8a855d">&#9670;&nbsp;</a></span>cbrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::cbrt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="abd8c75003f2a213607842f5d82eac806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8c75003f2a213607842f5d82eac806">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container1 , typename Container2 , typename saki::enable_if_nullptr_t&lt; saki::can_range_based_for_v&lt; Container1 &gt; &amp;&amp;saki::can_range_based_for_v&lt; Container2 &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::copy </td>
          <td>(</td>
          <td class="paramtype">const Container1 &amp;&#160;</td>
          <td class="paramname"><em>con1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container2 &amp;&#160;</td>
          <td class="paramname"><em>con2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(*std::begin(con2) = *std::begin(con1), std::begin(con2))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナとコンテナを渡すcopy </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">con1</td><td>コピーするコンテナクラス </td></tr>
    <tr><td class="paramname">con2</td><td>ペーストするコンテナクラス</td></tr>
  </table>
  </dd>
</dl>
<p>片方がendになったらコピー終了 </p>

</div>
</div>
<a id="a8bab6303ac2144b883080f04ebe26a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bab6303ac2144b883080f04ebe26a0e">&#9670;&nbsp;</a></span>copysign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SignType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::copysign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignType &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時符号コピー </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>絶対値 </td></tr>
    <tr><td class="paramname">y</td><td>符号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82551963a8cab889ca6f76ed346d6f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82551963a8cab889ca6f76ed346d6f4f">&#9670;&nbsp;</a></span>cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::cos </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時cos </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ラジアン角 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1f49aa2d1182883ae8b4c01b346cc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f49aa2d1182883ae8b4c01b346cc88">&#9670;&nbsp;</a></span>cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::cos </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int型のラジアン角 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f8167af6da5c9eb510d33dadae13708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8167af6da5c9eb510d33dadae13708">&#9670;&nbsp;</a></span>cosh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::cosh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時cosh </p>

</div>
</div>
<a id="afe248729248030bd5858469409e902d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe248729248030bd5858469409e902d2">&#9670;&nbsp;</a></span>cosh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::cosh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a457d78ffe360e1d8a78d14ec5dab38f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457d78ffe360e1d8a78d14ec5dab38f2">&#9670;&nbsp;</a></span>cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr U saki::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>外積 </p>

</div>
</div>
<a id="a980242869d69e47ff8b10335e86ccf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980242869d69e47ff8b10335e86ccf6f">&#9670;&nbsp;</a></span>cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt;U&gt; saki::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>外積 </p>

</div>
</div>
<a id="a467dee57b7bbe101146713a82acfe95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467dee57b7bbe101146713a82acfe95e">&#9670;&nbsp;</a></span>digit_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_arithmetic_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t saki::digit_count </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>整数部の桁数を数える関数 </p>
<p>log10でも可能だが、整数部だけならこちらを使ったほうが良い </p>

</div>
</div>
<a id="ae6eddecfb6a747238185b21c8ee1cd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eddecfb6a747238185b21c8ee1cd60">&#9670;&nbsp;</a></span>distanceXY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_x_v&lt; T1 &gt; &amp;&amp;saki::has_x_v&lt; T2 &gt; &amp;&amp;saki::has_y_v&lt; T1 &gt; &amp;&amp;saki::has_y_v&lt; T2 &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::distanceXY </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二点間の距離(XY) </p>

</div>
</div>
<a id="af202425b916b22c2b3a26731689d5c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af202425b916b22c2b3a26731689d5c21">&#9670;&nbsp;</a></span>distanceXYZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_x_v&lt; T1 &gt; &amp;&amp;saki::has_x_v&lt; T2 &gt; &amp;&amp;saki::has_y_v&lt; T1 &gt; &amp;&amp;saki::has_y_v&lt; T2 &gt; &amp;&amp;saki::has_z_v&lt; T1 &gt; &amp;&amp;saki::has_z_v&lt; T2 &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::distanceXYZ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二点間の距離(XYZ) </p>

</div>
</div>
<a id="a6bd1999d77d0ba6f6101747d82593c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd1999d77d0ba6f6101747d82593c66">&#9670;&nbsp;</a></span>distanceXZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_x_v&lt; T1 &gt; &amp;&amp;saki::has_x_v&lt; T2 &gt; &amp;&amp;saki::has_z_v&lt; T1 &gt; &amp;&amp;saki::has_z_v&lt; T2 &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::distanceXZ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二点間の距離(XZ) </p>

</div>
</div>
<a id="a708a45bd2134a3a276e7acb2566eb8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708a45bd2134a3a276e7acb2566eb8c1">&#9670;&nbsp;</a></span>distanceYZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename saki::enable_if_nullptr_t&lt; saki::has_y_v&lt; T1 &gt; &amp;&amp;saki::has_y_v&lt; T2 &gt; &amp;&amp;saki::has_z_v&lt; T1 &gt; &amp;&amp;saki::has_z_v&lt; T2 &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::distanceYZ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二点間の距離(YZ) </p>

</div>
</div>
<a id="a820a45ae402c8447bce4fee36a1f7d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820a45ae402c8447bce4fee36a1f7d62">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr U saki::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>内積 </p>

</div>
</div>
<a id="a5be905d72bf8dc80abc703fe69fa6fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be905d72bf8dc80abc703fe69fa6fec">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr U saki::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>内積 </p>

</div>
</div>
<a id="a990ff61a01d4cf819df3fe2774842acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990ff61a01d4cf819df3fe2774842acf">&#9670;&nbsp;</a></span>dot() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr U saki::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>内積 </p>

</div>
</div>
<a id="ace0188c33098d6ac615fc71e64ab6dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0188c33098d6ac615fc71e64ab6dda">&#9670;&nbsp;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時exchange </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>値を入れられる値 </td></tr>
    <tr><td class="paramname">new_val</td><td>値に入れる値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1268e543a60d43b04f1418f5ef3e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1268e543a60d43b04f1418f5ef3e41">&#9670;&nbsp;</a></span>exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::exp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時exp </p>

</div>
</div>
<a id="ab7883c6dfd2cf3ae04993f64d98345fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7883c6dfd2cf3ae04993f64d98345fc">&#9670;&nbsp;</a></span>exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::exp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a2e2d4ba08357bbab05c97ae261c80343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2d4ba08357bbab05c97ae261c80343">&#9670;&nbsp;</a></span>exp2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::exp2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時exp2 </p>

</div>
</div>
<a id="a35e9ce74a5f65c8d38a4901bf513ac1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e9ce74a5f65c8d38a4901bf513ac1e">&#9670;&nbsp;</a></span>exp2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::exp2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="aabb63a6251c75f6f1e76a58f5438de69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb63a6251c75f6f1e76a58f5438de69">&#9670;&nbsp;</a></span>expm1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::expm1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時expm1 </p>

</div>
</div>
<a id="ae4490f448ed3d82712306c54d6821788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4490f448ed3d82712306c54d6821788">&#9670;&nbsp;</a></span>expm1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::expm1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a224c4843b72acf995e13809a5caaafd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224c4843b72acf995e13809a5caaafd8">&#9670;&nbsp;</a></span>factorial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::factorial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>階乗(引数バージョン) </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>1からNまでの階乗を求める </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dead910b791cee99cf82d1bd2a5d90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dead910b791cee99cf82d1bd2a5d90c">&#9670;&nbsp;</a></span>factorial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::factorial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>階乗(仮引数バージョン) </p>

</div>
</div>
<a id="a93bb6ae29766c4204c1cf8dc5bab007c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bb6ae29766c4204c1cf8dc5bab007c">&#9670;&nbsp;</a></span>fibonacci() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::fibonacci </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フィボナッチ数列求める関数 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>求めたい番号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bbb434ee3c6d77eeb32b85bb9e316f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbb434ee3c6d77eeb32b85bb9e316f0">&#9670;&nbsp;</a></span>fibonacci() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::fibonacci </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フィボナッチ数列を求める関数 </p>

</div>
</div>
<a id="a0718c031975604811084b62bbba93f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0718c031975604811084b62bbba93f7f">&#9670;&nbsp;</a></span>floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::floor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時floor </p>
<p>|x|&gt;uint64_t_maxの場合は何も処理せず返す </p>

</div>
</div>
<a id="a327cd6800fef212948644f69cb31d4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327cd6800fef212948644f69cb31d4ff">&#9670;&nbsp;</a></span>floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::floor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a8a7b926b9d370e4a9aed84579675222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7b926b9d370e4a9aed84579675222c">&#9670;&nbsp;</a></span>fmod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::fmod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時float,double剰余 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>割られる数 </td></tr>
    <tr><td class="paramname">y</td><td>割る数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>剰余 </dd></dl>

</div>
</div>
<a id="ac9d00b62957aebad23850e2f470a8d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d00b62957aebad23850e2f470a8d9c">&#9670;&nbsp;</a></span>fmod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::fmod </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(x * y)
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>型が違う場合はそろえる </p>

</div>
</div>
<a id="a00438d1cd099cfd0e2938f9e3defd283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00438d1cd099cfd0e2938f9e3defd283">&#9670;&nbsp;</a></span>frexp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::frexp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時frexp </p>

</div>
</div>
<a id="a915bdd850c89e1ed06c5087790109f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915bdd850c89e1ed06c5087790109f11">&#9670;&nbsp;</a></span>frexp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::frexp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a0dfe75bfa0e5223a0390c5e2941e69bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfe75bfa0e5223a0390c5e2941e69bc">&#9670;&nbsp;</a></span>hypot() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::hypot </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&mdash;&mdash;2引数--&mdash;&mdash; </p>
<p>コンパイル時累乗 </p>

</div>
</div>
<a id="ad888da163ba5c006d664d564fb48f7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad888da163ba5c006d664d564fb48f7a7">&#9670;&nbsp;</a></span>hypot() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::hypot </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="add6327614e0d389d7545d1ffb151602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6327614e0d389d7545d1ffb151602b">&#9670;&nbsp;</a></span>hypot() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::hypot </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>型が違う場合はそろえる </p>

</div>
</div>
<a id="a56768ecf1270205a8c9b3ac8cdf4a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56768ecf1270205a8c9b3ac8cdf4a590">&#9670;&nbsp;</a></span>hypot() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::hypot </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&mdash;&mdash;3引数--&mdash;&mdash; </p>
<p>コンパイル時累乗 </p>

</div>
</div>
<a id="ad56e1232bb063b3bc0e7cf2b3f655247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56e1232bb063b3bc0e7cf2b3f655247">&#9670;&nbsp;</a></span>hypot() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::hypot </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="ada6f15bbf909992e4840325c0dae0c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6f15bbf909992e4840325c0dae0c42">&#9670;&nbsp;</a></span>hypot() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::hypot </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>型が違う場合はそろえる </p>

</div>
</div>
<a id="a582e9de82aa8572287c01530ae2626a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582e9de82aa8572287c01530ae2626a8">&#9670;&nbsp;</a></span>ilogb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr int saki::ilogb </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時ilogb </p>
<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a52a09941a80893dfdea6da4c220fba08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a09941a80893dfdea6da4c220fba08">&#9670;&nbsp;</a></span>int_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Integer , size_t N = saki::digit_count(std::numeric_limits&lt;Integer&gt;::max()) + 1, typename StringType  = saki::string_base&lt;T, N&gt;, typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; Integer &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringType saki::int_to_string </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>int型からstring型に変換 </p>
<p>固定長のためサイズ指定しなければならない </p>

</div>
</div>
<a id="a7fa7e4ec89e948874e42926e91d6dd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa7e4ec89e948874e42926e91d6dd4e">&#9670;&nbsp;</a></span>is_even()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::is_even </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>偶数がどうか判定する関数 </p>

</div>
</div>
<a id="a45597d7382905409bada2316f78502fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45597d7382905409bada2316f78502fc">&#9670;&nbsp;</a></span>is_fit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; saki::can_less_or_equal_v&lt; T &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::is_fit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>範囲内かどうかの判定を行う </p>
<p>if(a &lt;= x &amp;&amp; x &lt;= b)をis_fit(x,a,b)と書ける </p>

</div>
</div>
<a id="a09478d8cb01d75e93d34f884d7133dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09478d8cb01d75e93d34f884d7133dc9">&#9670;&nbsp;</a></span>is_fit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename MinType , typename MaxType , typename saki::enable_if_nullptr_t&lt; std::is_convertible_v&lt; MinType, First &gt; &amp;&amp;std::is_convertible_v&lt; MaxType, First &gt; &amp;&amp;saki::can_less_or_equal_v&lt; First &gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::is_fit </td>
          <td>(</td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MinType&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaxType&#160;</td>
          <td class="paramname"><em>max_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>型をそろえる </p>

</div>
</div>
<a id="a48b234a435a0e21df1507c4786b975b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b234a435a0e21df1507c4786b975b8">&#9670;&nbsp;</a></span>is_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename ... Args, typename saki::enable_if_nullptr_t&lt; std::conjunction_v&lt; std::is_convertible&lt; Args, First &gt;... &gt; &amp;&amp;std::conjunction_v&lt; saki::can_less&lt; First &gt;&gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::is_max </td>
          <td>(</td>
          <td class="paramtype">const First &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数の比較を一度に行える(&gt;=) </p>
<p>if(x &gt;= a &amp;&amp; x &gt;= b &amp;&amp; x &gt;= c)をis_max(x,a,b,c)と書ける </p>

</div>
</div>
<a id="a7780d542366428c85bfc48fdf43f54ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7780d542366428c85bfc48fdf43f54ee">&#9670;&nbsp;</a></span>is_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename ... Args, typename saki::enable_if_nullptr_t&lt; std::conjunction_v&lt; std::is_convertible&lt; First, Args &gt;... &gt; &amp;&amp;std::conjunction_v&lt; saki::can_greater&lt; First &gt;&gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::is_min </td>
          <td>(</td>
          <td class="paramtype">const First &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数の比較を一度に行える(&lt;=) </p>
<p>if(x &lt;= a &amp;&amp; x &lt;= b &amp;&amp; x &lt;= c)をis_min(x,a,b,c)と書ける </p>

</div>
</div>
<a id="a03cf21b9e2231e956f8da966f1e09d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cf21b9e2231e956f8da966f1e09d70">&#9670;&nbsp;</a></span>is_odd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::is_odd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>奇数がどうか判定する関数 </p>

</div>
</div>
<a id="a2168418bb30a857d2d018d0d05c7ace0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2168418bb30a857d2d018d0d05c7ace0">&#9670;&nbsp;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::isinf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時isinf </p>
<p>floating_point以外はfalse </p>

</div>
</div>
<a id="a446ca3f39e4dc8e57db4aafa03a4e232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446ca3f39e4dc8e57db4aafa03a4e232">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::isnan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not a Numberかどうか判定 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>判定する値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>NaNかどうか</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>判定する値</td></tr>
  </table>
  </dd>
</dl>
<p>floating_point以外はfalse </p>

</div>
</div>
<a id="a03b7a22945dcbce6e2bb0593025c90c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b7a22945dcbce6e2bb0593025c90c4">&#9670;&nbsp;</a></span>ldexp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IntegerT , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; IntegerT &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::ldexp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerT&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時ldexp </p>
<p>第二引数がint型じゃない場合に、int型にするためのもの </p>

</div>
</div>
<a id="aca2e4449261f40ee6f47abc49844e66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2e4449261f40ee6f47abc49844e66c">&#9670;&nbsp;</a></span>lerp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt;U&gt; saki::lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>線形補間 </p>
<p>Quaternionは使用していません </p>

</div>
</div>
<a id="acc3cd6d8e07cbfcd2691c4d9ffe25416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3cd6d8e07cbfcd2691c4d9ffe25416">&#9670;&nbsp;</a></span>lerp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt;U&gt; saki::lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>線形補間 </p>
<p>Quaternionは使用していません </p>

</div>
</div>
<a id="a1dc5233651ca71b38ed5a53ef304e480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5233651ca71b38ed5a53ef304e480">&#9670;&nbsp;</a></span>lerp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T1 , typename T2 , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt;U&gt; saki::lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>線形補間 </p>
<p>Quaternionは使用していません </p>

</div>
</div>
<a id="a64136b916afd50ceb9bfb93ae12c63fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64136b916afd50ceb9bfb93ae12c63fb">&#9670;&nbsp;</a></span>log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::log </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時log </p>

</div>
</div>
<a id="a7f260fd4311e2bd21ae770f8aed6fa81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f260fd4311e2bd21ae770f8aed6fa81">&#9670;&nbsp;</a></span>log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::log </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="aa1a5f3dfe15009e9e985b8b0647211e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a5f3dfe15009e9e985b8b0647211e6">&#9670;&nbsp;</a></span>log10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::log10 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時log10 </p>

</div>
</div>
<a id="a7e5fde452567de6eaae1d5c481497757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5fde452567de6eaae1d5c481497757">&#9670;&nbsp;</a></span>log10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::log10 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="ae0b2550b674acc69fa1fbe407917fdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2550b674acc69fa1fbe407917fdc7">&#9670;&nbsp;</a></span>log1p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::log1p </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時log1p </p>

</div>
</div>
<a id="aec755aa143bd9a0d03c5ebb2dc5dd3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec755aa143bd9a0d03c5ebb2dc5dd3de">&#9670;&nbsp;</a></span>log1p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::log1p </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="ac184cde6c3531e01531219e081e25452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac184cde6c3531e01531219e081e25452">&#9670;&nbsp;</a></span>log2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::log2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時log2 </p>

</div>
</div>
<a id="a8cb2f664389aab32abc797d9a60db4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb2f664389aab32abc797d9a60db4dc">&#9670;&nbsp;</a></span>log2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::log2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="ab7e81af48b13fbf88f135d296471bac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e81af48b13fbf88f135d296471bac1">&#9670;&nbsp;</a></span>logb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::logb </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時logb </p>

</div>
</div>
<a id="adf4ba562bb9897e98b75eb95027bfad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4ba562bb9897e98b75eb95027bfad5">&#9670;&nbsp;</a></span>logb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::logb </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="aa15664a63445d3539b40b774e556a45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15664a63445d3539b40b774e556a45b">&#9670;&nbsp;</a></span>multi_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename ... Args, typename saki::enable_if_nullptr_t&lt; std::conjunction_v&lt; std::is_convertible&lt; First, Args &gt;... &gt; &amp;&amp;std::conjunction_v&lt; saki::can_equal_equal&lt; First &gt;&gt; &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::multi_equal </td>
          <td>(</td>
          <td class="paramtype">const First &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数の比較を一度に行える </p>
<p>if(x == 1 || x == 2 || x == 3)をmulti_equal(x,1,2,3)と書ける </p>

</div>
</div>
<a id="a0ca208fb45c585d9cd23276fb91e40ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca208fb45c585d9cd23276fb91e40ee">&#9670;&nbsp;</a></span>normalize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt;U&gt; saki::normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>正規化 </p>
<dl class="section return"><dt>戻り値</dt><dd>正規化したもの </dd></dl>

</div>
</div>
<a id="aa38ed490dc1e7d5df7241eefd1c9453b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38ed490dc1e7d5df7241eefd1c9453b">&#9670;&nbsp;</a></span>normalize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt;U&gt; saki::normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>正規化 </p>
<dl class="section return"><dt>戻り値</dt><dd>正規化したもの </dd></dl>

</div>
</div>
<a id="afcef74d7e32ef8cf446d075beeed4b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcef74d7e32ef8cf446d075beeed4b41">&#9670;&nbsp;</a></span>normalize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U  = double, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt;U&gt; saki::normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>正規化 </p>
<dl class="section return"><dt>戻り値</dt><dd>正規化したもの </dd></dl>

</div>
</div>
<a id="aed742cc915a830fea9f4993c0a031c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed742cc915a830fea9f4993c0a031c45">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子 </p>

</div>
</div>
<a id="af91b2b2e47f5556c7604281af5223247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91b2b2e47f5556c7604281af5223247">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子 </p>

</div>
</div>
<a id="aa8b0dcab7f268e88f01c92c95cd12135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b0dcab7f268e88f01c92c95cd12135">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子 </p>

</div>
</div>
<a id="a6805502ef12cd12f6be61a958fd35aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6805502ef12cd12f6be61a958fd35aa7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子 </p>

</div>
</div>
<a id="ac0c806d3237b6718e95e9b71f838bcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c806d3237b6718e95e9b71f838bcc1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子 </p>

</div>
</div>
<a id="a8c33f5cbcafab48779b77c324716fed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c33f5cbcafab48779b77c324716fed9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="abf6f98117a7a12898df59d2041040000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6f98117a7a12898df59d2041040000">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="ae8393ad670f8bb199a92d4287bb1bf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8393ad670f8bb199a92d4287bb1bf3a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="a0d7159e145464e2deab2de2a76be1c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7159e145464e2deab2de2a76be1c00">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="a76722addb100e11d9eb9370ced3b027c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76722addb100e11d9eb9370ced3b027c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子 </p>

</div>
</div>
<a id="a4bef07cf55a40a115c89e6e20406b124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bef07cf55a40a115c89e6e20406b124">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>!=演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="ab9612151e27555ea59013c6a7da3322d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9612151e27555ea59013c6a7da3322d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(transform*スカラ) </p>

</div>
</div>
<a id="abd9716c5a5ccdc1cafb975df8897acb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9716c5a5ccdc1cafb975df8897acb3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(ベクトル*スカラ) </p>

</div>
</div>
<a id="a0fe5418c09468a2435c0a8a85a941174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe5418c09468a2435c0a8a85a941174">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(ベクトル*スカラ) </p>

</div>
</div>
<a id="af6d6668922b972ec01303867612e4783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d6668922b972ec01303867612e4783">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(ベクトル*スカラ) </p>

</div>
</div>
<a id="a9f06bb4644df2b78c5032c0656472d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06bb4644df2b78c5032c0656472d4c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(スカラ*transform) </p>

</div>
</div>
<a id="ab3e41594237dcaac47a2a27ed97f48f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e41594237dcaac47a2a27ed97f48f6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(スカラ*ベクトル) </p>

</div>
</div>
<a id="ad1caaaf5b1af879f2d546a4b2e10974e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1caaaf5b1af879f2d546a4b2e10974e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(スカラ*ベクトル) </p>

</div>
</div>
<a id="a7d5d04727e813b089aadf4b97247b64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5d04727e813b089aadf4b97247b64a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(スカラ*ベクトル) </p>

</div>
</div>
<a id="a59d261ceb3780fa55acc164671b67992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d261ceb3780fa55acc164671b67992">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(ベクトル) </p>

</div>
</div>
<a id="a19656e376d8720e2a67f3d08082770b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19656e376d8720e2a67f3d08082770b0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(ベクトル) </p>

</div>
</div>
<a id="a1db47b2e2e0826325ae66ee6216ba5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db47b2e2e0826325ae66ee6216ba5fc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(ベクトル) </p>

</div>
</div>
<a id="a8ec94b07795582554759e6f844b6055f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec94b07795582554759e6f844b6055f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(行列*スカラ) </p>

</div>
</div>
<a id="acc7d16324180fd378c3636f9bd961d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7d16324180fd378c3636f9bd961d20">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(スカラ*行列) </p>

</div>
</div>
<a id="ae7d9d53f473cbaa176e97500ea9ee491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d9d53f473cbaa176e97500ea9ee491">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>*演算子(行列*行列) </p>

</div>
</div>
<a id="a8f643bf5bc8002b1fefb916ff9c1d56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f643bf5bc8002b1fefb916ff9c1d56a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>+演算子 </p>

</div>
</div>
<a id="aba02830a0fe4fd92a264f80bd5f6cd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba02830a0fe4fd92a264f80bd5f6cd65">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>+演算子 </p>

</div>
</div>
<a id="af2eb9872710ab7ebca5e7a665f1a7cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2eb9872710ab7ebca5e7a665f1a7cd7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>+演算子 </p>

</div>
</div>
<a id="a7c132b30fc5554123e166c29a5292607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c132b30fc5554123e166c29a5292607">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>+演算子 </p>

</div>
</div>
<a id="a10eb3090250dfcb43dd1c7579b6b473c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eb3090250dfcb43dd1c7579b6b473c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>+演算子 </p>

</div>
</div>
<a id="a1a8b351ef2a4ccd991bc774540619b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8b351ef2a4ccd991bc774540619b3a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>-演算子 </p>

</div>
</div>
<a id="a9b9369c0656bd3b8b940eadf027b41f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9369c0656bd3b8b940eadf027b41f3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>-演算子 </p>

</div>
</div>
<a id="a8697755777c25ac12687ea8804f80331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8697755777c25ac12687ea8804f80331">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>-演算子 </p>

</div>
</div>
<a id="ab08546185e6a03ba6496daf21d943799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08546185e6a03ba6496daf21d943799">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>-演算子 </p>

</div>
</div>
<a id="aa7474901f1f0d3a80142ed713b75ed5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7474901f1f0d3a80142ed713b75ed5e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>-演算子 </p>

</div>
</div>
<a id="aae41cae2f869873e083124ad5f1b5f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae41cae2f869873e083124ad5f1b5f67">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(スカラ) </p>

</div>
</div>
<a id="a15270d7bd5638726debe317a16a6b26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15270d7bd5638726debe317a16a6b26b">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(スカラ) </p>

</div>
</div>
<a id="a5525c6da34ded0620ee6d965e687bedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5525c6da34ded0620ee6d965e687bedc">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(スカラ) </p>

</div>
</div>
<a id="ab12f7d971656317d7e0502bf64fe762a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12f7d971656317d7e0502bf64fe762a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(スカラ) </p>

</div>
</div>
<a id="aee335c88f00f71e52e37fd4bfb77b181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee335c88f00f71e52e37fd4bfb77b181">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(ベクトル) </p>

</div>
</div>
<a id="ac72c945dc5e1e8fe6065beac4a310a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72c945dc5e1e8fe6065beac4a310a54">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(ベクトル) </p>

</div>
</div>
<a id="af613b8219c84ed98901c66a082938a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af613b8219c84ed98901c66a082938a61">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(ベクトル) </p>

</div>
</div>
<a id="ac69ad44a115a64e5874921344c34d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69ad44a115a64e5874921344c34d62e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/演算子(スカラ) </p>

</div>
</div>
<a id="abf390d4e6c19fdb92d3a68afb7e71032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf390d4e6c19fdb92d3a68afb7e71032">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; saki::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1string__base.html">string_base</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stringの出力 </p>

</div>
</div>
<a id="a5ce8a66ed6ece15fa9ddeaec2746374d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce8a66ed6ece15fa9ddeaec2746374d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1array.html">array</a>&lt; T, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子 </p>

</div>
</div>
<a id="a57a23952c9becf92a51ff1742f645d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a23952c9becf92a51ff1742f645d66">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子 </p>

</div>
</div>
<a id="afde7d962261485c2054cd1a98ed337ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde7d962261485c2054cd1a98ed337ed">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1transform.html">saki::transform</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="a3ce1faca02399d52a09851a1b6e8afe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce1faca02399d52a09851a1b6e8afe3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子 </p>

</div>
</div>
<a id="abe77ceb7257097320a66f9f182d11111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe77ceb7257097320a66f9f182d11111">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子 </p>

</div>
</div>
<a id="a2aafc5056183a1a522b89497ee3439e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aafc5056183a1a522b89497ee3439e9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子 </p>

</div>
</div>
<a id="af2a10e5e2974f482b6da75d9137dc143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a10e5e2974f482b6da75d9137dc143">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">vector4</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="a5f3eb3ebd6a3ee43771849069101153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3eb3ebd6a3ee43771849069101153f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="a07efea0cf7385fc13c00519e8f0f7732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07efea0cf7385fc13c00519e8f0f7732">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="a67e5e15cae6e9152e0bd5ac2e1705da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e5e15cae6e9152e0bd5ac2e1705da4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子 </p>

</div>
</div>
<a id="a1ffbf8122dda5209dc384e64747bec32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffbf8122dda5209dc384e64747bec32">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool saki::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>==演算子(型不一致) </p>
<p>この関数の使用は推奨しない </p>

</div>
</div>
<a id="aa5b66f18d7c8c94b4c50731449ed3240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b66f18d7c8c94b4c50731449ed3240">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時累乗 </p>

</div>
</div>
<a id="a53b0e93733e85d7c6ab17aea25072536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b0e93733e85d7c6ab17aea25072536">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="aede1168d9c20adf475c0a27670925c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1168d9c20adf475c0a27670925c34">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto saki::pow </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>型をそろえる </p>

</div>
</div>
<a id="a636caf16f2f00cb734cc867646ac233f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636caf16f2f00cb734cc867646ac233f">&#9670;&nbsp;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T saki::random </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>random_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>random_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最小値と最大値を引数にとり、その間からランダムな値を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_min</td><td>最小値 </td></tr>
    <tr><td class="paramname">random_max</td><td>最大値</td></tr>
  </table>
  </dd>
</dl>
<p>最大値を含むランダムな値を返す </p>

</div>
</div>
<a id="abda5ab30bf4dc9240857d62d56e590f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda5ab30bf4dc9240857d62d56e590f9">&#9670;&nbsp;</a></span>scaling() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt;T&gt; saki::scaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡縮 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>拡縮量(vector2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affcd920fe27abc17e5fa50f04bfabe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcd920fe27abc17e5fa50f04bfabe05">&#9670;&nbsp;</a></span>scaling() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt;T&gt; saki::scaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡縮 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>拡縮量(vector3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aededd0f357c48d1e96af77b06cb3e786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aededd0f357c48d1e96af77b06cb3e786">&#9670;&nbsp;</a></span>scaling() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt;T&gt; saki::scaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡縮 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>拡縮量(vector4) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac51e06f83630682641e0d99d5c957a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51e06f83630682641e0d99d5c957a9c">&#9670;&nbsp;</a></span>sigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = int, typename Func  = saki::return_param, typename saki::enable_if_nullptr_t&lt; std::is_arithmetic_v&lt; T &gt; &amp;&amp;std::is_invocable_v&lt; Func, T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::sigma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>Func()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数学のシグマを簡単に実装 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>初期値 </td></tr>
    <tr><td class="paramname">end</td><td>繰り返しの終わり(この値を使用したら終了) </td></tr>
    <tr><td class="paramname">f</td><td>関数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>計算結果</dd></dl>
<p>start&gt;endの場合、0が返る、算術型のみ対応 </p>

</div>
</div>
<a id="a5ed78463ed5808788e1b77eeecd9352a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed78463ed5808788e1b77eeecd9352a">&#9670;&nbsp;</a></span>signbit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool saki::signbit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>負数かどうか判定する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>判定する値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>負数かどうか </dd></dl>

</div>
</div>
<a id="a743f7284cdebb6406db9b37e42bcd730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743f7284cdebb6406db9b37e42bcd730">&#9670;&nbsp;</a></span>sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::sin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時sin </p>

</div>
</div>
<a id="a9fd77d1e52189e28f4a5d069891501cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd77d1e52189e28f4a5d069891501cf">&#9670;&nbsp;</a></span>sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::sin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="abe1ef6db83d59a5eb2daac9bff09d312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1ef6db83d59a5eb2daac9bff09d312">&#9670;&nbsp;</a></span>sinh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::sinh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時sinh </p>

</div>
</div>
<a id="a8199390b7650fdebe491aaeb4c3a44c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8199390b7650fdebe491aaeb4c3a44c3">&#9670;&nbsp;</a></span>sinh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::sinh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="ad15185db28f6e77d65411ca83f64f5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15185db28f6e77d65411ca83f64f5bb">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename &gt; typename Container = std::vector, typename T , typename saki::enable_if_nullptr_t&lt; saki::has_check_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;std::string, std::allocator&lt;std::string&gt; &gt; saki::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>split_separation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>string型を指定された文字で区切ったものをvectorで返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>区切る対象の文字列 </td></tr>
    <tr><td class="paramname">split_separation</td><td>区切りを複数選択できるクラス </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>区切った文字列を格納するvectorクラス</dd></dl>
<p>bool check(char)の関数を持っているクラスならなんでも受け取れ、falseの間文字を格納し続けます </p>

</div>
</div>
<a id="ac1464436ac78ade2ba14371e2efe1fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1464436ac78ade2ba14371e2efe1fd2">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename &gt; typename Container = std::vector, typename First , typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;std::string, std::allocator&lt;std::string&gt; &gt; saki::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first_separation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T ...&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>string型を指定された文字で区切ったものをvectorで返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>区切る対象の文字列 </td></tr>
    <tr><td class="paramname">first_separation</td><td>1つ目の区切り文字 </td></tr>
    <tr><td class="paramname">t</td><td>2つ目以降の区切り文字 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>区切った文字列を格納するvectorクラス </dd></dl>

</div>
</div>
<a id="a5c2f6c98a144d6ba6683c86c865fd595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2f6c98a144d6ba6683c86c865fd595">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::sqrt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時平方根 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>平方根を求める値</td></tr>
  </table>
  </dd>
</dl>
<p>アルゴリズムはバビロニアの平方根を利用 </p>

</div>
</div>
<a id="a66fac13294984ad19b8b7fec3b5466b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fac13294984ad19b8b7fec3b5466b5">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::sqrt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a491321db8475898649b625dca5401726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491321db8475898649b625dca5401726">&#9670;&nbsp;</a></span>tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::tan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時tan </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ラジアン角 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52704083849bbdf4ab635cca985c00ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52704083849bbdf4ab635cca985c00ae">&#9670;&nbsp;</a></span>tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::tan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int型のラジアン角 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2674216630169ce211f8076492ce14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2674216630169ce211f8076492ce14e">&#9670;&nbsp;</a></span>tanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::tanh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイル時tanh </p>

</div>
</div>
<a id="a5faf83bc9a4a7e981275deba551d2f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faf83bc9a4a7e981275deba551d2f3f">&#9670;&nbsp;</a></span>tanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::tanh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="af9f6d8f2c0663a0452c7edd17bf5daf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f6d8f2c0663a0452c7edd17bf5daf0">&#9670;&nbsp;</a></span>to_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::to_degree </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RadianからDegreeに変換 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rad</td><td>Degreeに変換するRadian </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7cb33956f8d7354b485aee878d7805d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cb33956f8d7354b485aee878d7805d">&#9670;&nbsp;</a></span>to_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::to_degree </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a27595b1e53058ce792db7f8d29e2e9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27595b1e53058ce792db7f8d29e2e9af">&#9670;&nbsp;</a></span>to_radian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_floating_point_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T saki::to_radian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DegreeからRadianに変換 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">deg</td><td>Radianに変換するDegree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa671d122197cf10439eee0d271f51fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa671d122197cf10439eee0d271f51fe6">&#9670;&nbsp;</a></span>to_radian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename saki::enable_if_nullptr_t&lt; std::is_integral_v&lt; T &gt;&gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr double saki::to_radian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数がint型の場合に、戻り値をdouble型にするためのもの </p>

</div>
</div>
<a id="a2311e77a2bed9d914a6b3e8056d6023a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2311e77a2bed9d914a6b3e8056d6023a">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt;T&gt; saki::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector2.html">saki::vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>平行移動 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>移動量(vector2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a492418470fa4dedb2065e7916460f0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492418470fa4dedb2065e7916460f0e0">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt;T&gt; saki::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector3.html">saki::vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>平行移動 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>移動量(vector3) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdd23c2e56d1500ae2e8b662c5ddcf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd23c2e56d1500ae2e8b662c5ddcf7c">&#9670;&nbsp;</a></span>translate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsaki_1_1matrix.html">matrix</a>&lt;T&gt; saki::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaki_1_1vector4.html">saki::vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>平行移動 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>移動量(vector4) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
